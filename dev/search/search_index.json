{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to StepUp RepRep","text":"<p>StepUp RepRep is the publication build tool for Reproducible Reporting. It is a domain-specific extension of a powerful universal build tool called StepUp Core.</p> <p>To get started, we recommend to follow the Template Tutorial in this documentation. StepUp RepRep will be installed in your instance of the template, as part of the setup.</p> <p>If you want to gain a more in-depth understanding of how StepUp works, the StepUp Core tutorials will take you through all the basics.</p>"},{"location":"#quick-demo","title":"Quick Demo","text":"<p>The following screen cast shows StepUp RepRep in action:</p> <ul> <li>First, StepUp is started with 4 workers   to complete the steps in the RepRep publication template from scratch.</li> <li>After the build has completed,   the file <code>generate.py</code> is modified,   whose output is used in a matplotlib plot created by <code>plot.py</code>,   whose output is included in a LaTeX document, etc.</li> <li>Stepup sees the changes.   As soon as the user presses <code>r</code>,   StepUp executes the necessary steps to rebuild all artifacts   that are (indirectly) affected by the change in <code>generate.py</code>.</li> <li>Finally, the user presses <code>q</code> to exit StepUp.</li> </ul>"},{"location":"#why-was-stepup-reprep-created","title":"Why Was StepUp RepRep Created?","text":"<p>StepUp RepRep aims to facilitate the reproducibility and data management of scientific publications. It targets the last mile of the publication process: The creation of a publication from raw research results.</p> <p>The making of a scientific publication involves many moving parts, which are not easily connected and shared among co-authors. Raw results need to be analyzed, tabulated, and plotted and presented in a convenient way to the reader. Today, such data processing is increasingly done using scripting languages (Python, R, Notebooks, \u2026) because they allow more advanced analysis than spreadsheets or manual calculations. Too often, however, the results of such scripting tools are incorporated into a publication (or subsequent analysis tool) by tedious copy-paste or manual import. While each tool can be very advanced, the transfer of information from one step to the next is often not. This becomes problematic in at least the following scenarios:</p> <ol> <li> <p>When trying to reproduce the results of a paper, long after it was published,    you may not remember how intermediate results were transferred between different analysis tools    and how these results were transformed into a presentable form in the publication.    In such situations, published results are not easily reproducible.    (They may still be formally reproducible, given an almost infinite amount of time and coffee.)</p> </li> <li> <p>If a small error in one of the analysis scripts is fixed,    at least a part of the analysis must be repeated.    Every step after the fixed part and all data transfers between them must also be repeated.    Especially if such fixes occur regularly in the writing process,    the repetitive analysis and data transfers become very error-prone,    which undermines the quality of the publication.</p> </li> <li> <p>Because at least one person needs to know how to get data into and out of an analysis tool,    the raw data and scripts will primarily reside on that person\u2019s computer or account.    Even if the data and scripts are archived and made available,    the knowledge of how to reproduce these results is not easily shared.</p> </li> </ol> <p>StepUp RepRep overcomes these difficulties by fully formalizing the interactions between different scripts, analysis tools and authoring software. Once configured, the entire process, from raw results and source files all the way to a ZIP file to be uploaded to the publisher, can be reproduced by simply running the <code>stepup</code> program once.</p>"},{"location":"#git-and-virtual-environments","title":"Git and Virtual Environments","text":"<p>A project produced with StepUp RepRep uses the following technologies to further facilitate data management and reproducibility:</p> <ul> <li> <p>The entire publication source,   along with all analysis scripts necessary to generate final tables and figures,   is developed in a Git repository.   All co-authors have access to this repository,   so they can (if they wish) verify every detail that leads to the published results.</p> </li> <li> <p>A virtual software environment (Pip or Conda) is configured,   allowing all co-authors to locally install all software required to reproduce   the entire publication from its sources.`</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Effort-based Versioning. (Changes to features documented as \u201cexperimental\u201d will not increment macro and meso version numbers.)</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"<p>(no summary yet)</p>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Ignore links returned by the Zenodo API that are not strings in <code>sync_zenodo</code>.</li> <li>Amend a <code>make_inventory</code> step with all files in an inventory as inputs.</li> </ul>"},{"location":"changelog/#304-2025-06-21","title":"3.0.4 - 2025-06-21","text":"<p>Support for ORCID field in <code>sync_zenodo</code>.</p>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Added ORCID field to the author metadata in the <code>sync_zenodo</code> configuration file.</li> </ul>"},{"location":"changelog/#303-2025-06-14","title":"3.0.3 - 2025-06-14","text":"<p>Replace a few more markdown imports.</p>"},{"location":"changelog/#302-2025-06-14","title":"3.0.2 - 2025-06-14","text":"<p>Small improvements and a wrapper for git commands that depend on the commit id.</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>wrap_git()</code> to define shell commands   (typically <code>git ...</code>) that need to be re-executed when the current git branch or commit changes.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Use the <code>markdown-it-py</code> package instead of <code>markdown</code>   for more precise and faster markdown rendering.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Make <code>flatten_latex()</code> work with other file extensions.</li> </ul>"},{"location":"changelog/#301-2025-05-31","title":"3.0.1 - 2025-05-31","text":"<p>Integration with papermill to execute notebooks, and a few bug fixes.</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Execution of notebooks with papermill,   using the <code>execute_papermill()</code> API function.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed outdated information in the Zenodo synchronization documentation,   and fixed corresponding outdated code.</li> <li>Remove <code>linear=True</code> argument when saving a PDF with MuPDF   because it is no longer supported as of MuPDF 1.26.   (It was not terribly useful in the first place.)   For more details, see https://artifex.com/blog/mupdf-removes-linearisation.</li> </ul>"},{"location":"changelog/#300-2025-05-11","title":"3.0.0 - 2025-05-11","text":"<p>Major release with breaking changes, compatible with StepUp Core 3.</p>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Breaking:<ul> <li>Compatibility with StepUp Core 3.</li> <li>Migrated <code>render_jinja()</code> to StepUp Core 3.</li> </ul> </li> </ul>"},{"location":"changelog/#236-2025-04-24","title":"2.3.6 - 2025-04-24","text":"<p>Make <code>sanitize_bibtex()</code> work without LaTeX and add support for TOML files in <code>render_jinja()</code>.</p>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for TOML files in <code>render_jinja()</code>.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Make <code>sanitize_bibtex()</code> usable without LaTeX.</li> <li>New output files in the LaTeX fls file are treated as volatile outputs.</li> </ul>"},{"location":"changelog/#235-2025-03-13","title":"2.3.5 - 2025-03-13","text":"<p>Bug fix in <code>rr-cat-pdf</code> and simplify journal abbreviation in <code>rr-bibsane</code>. This requires an update the <code>bibsane.yaml</code> configuration file.</p>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>The <code>--insert-blank</code> opton of <code>rr-cat-pdf</code> was always active,   even when not present on the command line, which is now fixed.</li> <li> <p>The <code>abbreviate_journal</code> feature of bibsane used to work with a cache file,   which was a remnant from an older implementation.   This no longer made much sense (because pyiso4 is fast enough)   and it cache files may cause non-reproducible behavior.   (They are both inputs and outputs.)   For these reasons, the cache feature is replaced by two configuration fields in <code>bibsane.yaml</code>:</p> <ul> <li>A boolean flag <code>abbreviate_journals</code> to enable abbreviations.</li> <li>An optional mapping <code>custom_abbreviations</code> with abbreviation overrides   for when pyiso4 does not give the desired result.</li> </ul> </li> </ul> <p>An external file with abbreviations is no longer needed.   They are just included in the <code>bibsane.yaml</code> file.   (This also means that old bibsane.yaml config files may need to be updated.)   See Sanitizing BibTeX files for more details.</p>"},{"location":"changelog/#v2.3.4","title":"2.3.4 - 2025-03-09","text":"<p>Improved handling of LaTeX fls file and refactored <code>make_inventory()</code> function.</p>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>The arguments of <code>make_inventory()</code> are now variadic.   Files to be included are passed as positional arguments and the last positional argument   is the inventory file to be written.   An optional argument <code>path_def</code> can be used to specify an inventory definition file.</li> <li>The <code>include-git</code> and <code>exclude-git</code> commands in an inventory definition now accept arguments,   which are passed to the <code>git ls-files</code> command.</li> <li>LaTeX output files inferred from the <code>.fls</code> file are filtered in the same ways as input files.   LaTeX sometimes writes output files to <code>~/.texlive2023/</code> which should be ignored by StepUp.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li><code>rr-flatten-latex</code> now correctly handles empty tex files.</li> </ul>"},{"location":"changelog/#v2.3.3","title":"2.3.3 - 2025-03-03","text":"<p>A few minor improvements related to LaTeX and BibTeX, and parameterized Jupyter notebooks.</p>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Improve detection of inputs and (volatile) outputs when compiling a LaTeX document:<ul> <li>The <code>-recorder</code> option of <code>latex</code> is used to identify inputs and outputs more precisely.</li> <li>The manual override <code>%REPREP input</code> is replaced by <code>%REPREP inp</code>.</li> <li>New manual overrides are supported for (volatile) outputs: <code>%REPREP out</code> and <code>%REPREP vol</code>.</li> </ul> </li> <li>Add <code>nbargs</code> option to <code>convert_jupyter()</code>,   to call a notebook with arguments.   If a <code>list</code> or a <code>dict</code> is given, the data is convert to JSON.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Add <code>overwrite</code> option to <code>sanitize_bibtex()</code>,   to flag that <code>path_out</code> refers to an input file to be overwritten,   instead of trying to track it as an output file.</li> </ul>"},{"location":"changelog/#v2.3.2","title":"2.3.2 - 2025-02-24","text":"<p>This release makes <code>compile_typst</code> compatible with Typst 0.13, and drops support for markdown-katex.</p>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Configuration for development with devenv</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Drop support for the ailing markdown_katex integration.   (Typst can be used to achieve similar results much more efficiently).</li> <li>Update <code>compile_typst</code> for Typst 0.13</li> </ul>"},{"location":"changelog/#v2.3.1","title":"2.3.1 - 2025-02-12","text":"<p>This is a minor bugfix release.</p>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Remove some debug output.</li> </ul>"},{"location":"changelog/#v2.3.0","title":"2.3.0 - 2025-02-12","text":"<p>This release adds support for Jupyter notebooks with <code>convert_jupyter()</code> and introduces small breaking changes to the API. Other noteworthy changes include new options to the <code>compile_typst()</code> function, more ways to specify variables in <code>render_jinja()</code>.</p>"},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Execute and convert Jupyter notebooks with <code>convert_jupyter()</code>.</li> <li><code>rr-bibsane</code> is now part of StepUp RepRep, instead of using the (retired) <code>bibsane</code> package.   The main difference, other than the improved integration with StepUp RepRep,   is that journal abbreviations are now generated with pyiso4   instead of the abrevvIso Web API.   It has a corresponding <code>sanitize_bibtex()</code> function   in <code>stepup.reprep.api</code>.</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Extend <code>compile_typst()</code> with additional options:<ul> <li>Specification of the output file.</li> <li>Key-value pairs for the <code>--input</code> argument.</li> <li>PNG and SVG output formats (multipage is not working yet).</li> <li>Optional inventory output file.</li> <li>Pass-through arguments for <code>typst</code></li> </ul> </li> <li>Breaking changes to existing API:<ul> <li><code>convert_pdf()</code> and related functions are renamed:<ul> <li><code>convert_pdf()</code> becomes <code>convert_mutool()</code></li> <li><code>convert_pdf_png()</code> becomes <code>convert_mutool_png()</code></li> </ul> </li> <li><code>convert_svg()</code> and related functions are renamed:<ul> <li><code>convert_svg()</code> becomes <code>convert_inkscape()</code></li> <li><code>convert_svg_pdf()</code> becomes <code>convert_inkscape_pdf()</code></li> <li><code>convert_svg_png()</code> becomes <code>convert_inkscape_png()</code></li> </ul> </li> <li>The <code>inkscape_args</code> of <code>convert_inkscape()</code>   must now be a list instead of a string.</li> <li><code>compile_latex()</code> no longer creates   an inventory file by default.   To recover the old behavior, add <code>inventory=True</code> to the arguments   or set the environment variable <code>REPREP_LATEX_INVENTORY=\"1\"</code>.</li> <li><code>compile_latex()</code> no longer calls <code>bibsane</code>   when the LaTeX source has a BibTeX bibliography.   If you want to sanitize the BibTeX file, call <code>sanitize_bibtex()</code>   after <code>compile_latex()</code>.</li> <li>The <code>paths_variables</code> argument of <code>render_jinja()</code>   has been replaced by a variadic positional parameter (i.e. <code>*paths_variables</code>).</li> </ul> </li> <li>Other changes<ul> <li>Change <code>convert_weasyprint()</code>   to perform the conversion in a single step.</li> <li>Improve handling of arguments and dependencies in   <code>convert_markdown()</code></li> <li><code>render_jinja()</code> now accepts JSON and YAML files   with variables for Jinja2 templates.   In addition, one may specify a dictionary with variables directly when calling the function.</li> <li>Documentation improvements.</li> </ul> </li> </ul>"},{"location":"changelog/#v2.2.3","title":"2.2.3 - 2025-02-05","text":"<p>This release uses the new <code>STEPUP_EXTERNAL_SOURCES</code> environment variable introduced in StepUp Core 2.0.6.</p>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Switch from SemVer to   EffVer.</li> <li>Scripts that automatically detect dependencies   (<code>rr-compile-latex</code>, <code>rr-compile-typst</code> and <code>rr-convert-inkscape</code>)   now also use the new <code>STEPUP_EXTERNAL_SOURCES</code> environment variable   introduced in StepUp Core 2.0.6.</li> </ul>"},{"location":"changelog/#v2.2.2","title":"2.2.2 - 2025-01-31","text":"<p>This is a bugfix release addressing minor issues in the Typst support.</p>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Only call <code>sys.exit</code> in <code>rr-compile-typst</code> if the returncode is non-zero.   This allows for other scripts to call its main function without exiting   in case of a succeeded typst build.</li> </ul>"},{"location":"changelog/#v2.2.1","title":"2.2.1 - 2025-01-31","text":"<p>This is a bugfix release addressing minor issues in the Typst support.</p>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Fix returncode of the <code>rr-compile-typst</code> command (now passes through returncode of <code>typst build</code>).</li> <li>By default, depfiles created by <code>typst build</code> are now stored in a temporary directory,   to avoid littering the working directory.   You can keep depfiles by setting the environment variable <code>REPREP_KEEP_TYPST_DEPS=\"1\"</code>,   or with the argument <code>keep_deps=True</code> in <code>compile_typst()</code>.   (Either one will .)</li> </ul>"},{"location":"changelog/#v2.2.0","title":"2.2.0 - 2025-01-29","text":"<p>This release adds experimental support for typst. It also introduces a few breaking API changes for the sake of consistency. (More breaking changes should be expected in the near future.)</p>"},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Experimental support for Typst.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Rename API functions:<ul> <li><code>latex()</code> -&gt; <code>compile_latex()</code></li> <li><code>latex_flat()</code> -&gt; <code>flatten_latex()</code></li> <li><code>latex_diff()</code> -&gt; <code>diff_latex()</code></li> </ul> </li> </ul>"},{"location":"changelog/#v2.1.0","title":"2.1.0 - 2025-01-27","text":"<p>This release contains a few minor breaking changes for the sake of internal consistency.</p>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>The conversion with Inkscape has become a single step.   (It was first split up in a step scanning for dependencies followed by the actual conversion.)</li> <li>Add more entrypoints for command-line utilities in StepUp RepRep.   Existing ones were renamed from <code>reprep-*</code> to <code>rr-*</code>.</li> <li>Rename module <code>stepup.reprep.render</code> to <code>stepup.reprep.render_jinja</code>.</li> <li>Rename API function: <code>render()</code> -&gt; <code>render_jinja()</code></li> </ul>"},{"location":"changelog/#v2.0.2","title":"2.0.2 - 2025-01-22","text":"<p>This is the first release of StepUp RepRep that is compatible with StepUp Core 2.0.0. (Earlier 2.0 releases were yanked due to packaging issues.)</p>"},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Add <code>smarty</code> extension to markdown conversion.</li> <li>Add option to insert blank page after odd-paged PDF when concatenating PDFs.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Compatibility with StepUp Core 2.0.0, which breaks compatibility with older StepUp Core versions.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Use <code>shlex</code> for building shell commands in <code>stepup.reprep.api</code> to avoid shell injection.</li> </ul>"},{"location":"changelog/#v1.4.1","title":"1.4.1 - 2024-09-02","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>An extra argument was added to <code>convert_markdown</code> to specify CSS files.</li> <li>Support default arguments for <code>convert_markdown</code> defined as environment variables:   <code>${REPREP_KATEX_MACROS}</code> and <code>${REPREP_MARKDOWN_CSS}</code>.</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fix bug: put header output of <code>markdown_katex</code> plugin in the HTML header.</li> <li>Fix bug: rewrite paths to CSS files in <code>convert_markdown</code>   to be relative to the parent of the output HTML file.</li> </ul>"},{"location":"changelog/#v1.4.0","title":"1.4.0 - 2024-08-27","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>The unplot script, a sanitized version of Depix.   It converts paths from SVG files back into data,   which can be used to reverse-engineer data sets from plots.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Move <code>load_module_file</code> from StepUp Core to <code>stepup.reprep.render</code>   and improve it to facilitate local imports.</li> </ul>"},{"location":"changelog/#v1.3.0","title":"1.3.0 - 2024-06-28","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>The script <code>rr-sync-zenodo</code> and corresponding StepUp API function <code>sync_zenodo()</code>   synchronize your local data with a draft dataset on Zenodo.</li> <li>Small documentation updates</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Upgraded dependency markdown-katex to version 202406.1035   and enabled concurrency for markdown conversion with equations.</li> <li>Scrub PDF files after opening them with <code>fitz</code>.   See https://github.com/pymupdf/PyMuPDF/issues/3635</li> </ul>"},{"location":"changelog/#v1.2.1","title":"1.2.1 - 2024-05-27","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Conversion from HTML to weasyprint is now a two-step process and includes detection   of implicit input files used in the HTML to PDF conversion. (Images and external CCS)</li> <li>Improved reusability of script modules:   <code>add_notes_pdf</code>, <code>check_hrefs</code>, <code>convert_inkscape</code>, <code>convert_markdown</code>,   <code>convert_weasyprint</code>, <code>latex</code>, <code>latex_flat</code>, <code>make_inventory</code>, <code>normalized_pdf</code>,   <code>nup_pdf</code>, <code>raster_pdf</code>, <code>render</code> and <code>zip_inventory</code>.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Fixed a few errors in the HTML generated by <code>convert_markdown()</code></li> </ul>"},{"location":"changelog/#v1.2.0","title":"1.2.0 - 2024-05-20","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li><code>rr-zip-inventory</code> command to manually create a reproducible ZIP file from an <code>inventory.txt</code> file.</li> <li>More documentation on how to work with inventory files.</li> <li>Tutorial for archiving StepUp publication Git repositories.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Renamed all <code>MANIFEST</code> and <code>manifest</code> occurrences to <code>inventory</code>   and removed dependency of setuptools for processing such files.</li> <li>The API of <code>make_inventory</code> is made simpler than that of <code>make_manifest</code>.</li> <li>The commands supported in <code>inventory.def</code> files now differ from those in setuptools:   <code>include</code>, <code>exclude</code>, <code>include-git</code>, <code>exclude-git</code>, <code>include-workflow</code> and <code>exclude-workflow</code>.</li> <li>The css style has been made customizable in <code>convert_markdown</code>.</li> <li>KaTeX is now optional in <code>convert_markdown</code>.</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>An error message is raised when trying to a put a directory in an inventory file.</li> <li>Symbolic links are no longer dereferenced when they are listed in an inventory file.</li> <li>Symbolic links are archived in ZIP files without dereferencing.</li> </ul>"},{"location":"changelog/#v1.1.2","title":"1.1.2 - 2024-05-16","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Nicer fix for concurrent Inkscape SVG to PDF or PNG conversion   (with <code>SELF_CALL=x</code>).   See: https://gitlab.com/inkscape/inkscape/-/issues/4716</li> <li>Make unit tests work with stepup-core 1.2.2.</li> </ul>"},{"location":"changelog/#v1.1.1","title":"1.1.1 - 2024-05-07","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Inkscape SVG to PDF or PNG conversion now works also in parallel,   thanks to the workaround posted here:   https://gitlab.com/inkscape/inkscape/-/issues/4716</li> <li>LibrOffice PDF conversion now works also in parallel,   thanks to the workaround posted here:   https://bugs.documentfoundation.org/show_bug.cgi?id=106134</li> <li>Inkscape conversion no longer opens files in write mode,   which triggered the watcher of StepUp Core.</li> <li>Fixed packaging mistake that confused PyCharm and Pytest.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Documentation improvements</li> </ul>"},{"location":"changelog/#v1.1.0","title":"1.1.0 - 2024-05-02","text":""},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Documentation improvements</li> <li>Unit tests are made compatible with StepUp Core 1.2.0.</li> </ul>"},{"location":"changelog/#v1.0.0","title":"1.0.0 - 2024-04-25","text":"<p>Initial release</p>"},{"location":"development/","title":"Developer Notes","text":"<p>If you would like to contribute, please read CONTRIBUTING.md.</p>"},{"location":"development/#development-environment","title":"Development environment","text":"<p>If you break your development environment, you can discard it by running <code>git clean -dfX</code> and repeating the instructions below.</p> <p>First, create a StepUp Core development installation. The following commands assume you create <code>stepup-core</code> and <code>step-reprep</code> source trees as subdirectories of the same parent.</p> <p>Clone the StepUp RepRep repository and create a virtual environment using the following commands</p> <pre><code>git clone git@github.com:reproducible-reporting/stepup-reprep.git\ncd stepup-reprep\npre-commit install\npython -m venv venv\n</code></pre> <p>Put the following two lines in <code>.envrc</code>:</p> <pre><code>source venv/bin/activate\nexport XDG_CACHE_HOME=\"${VIRTUAL_ENV}/cache\"\nexport STEPUP_DEBUG=\"1\"\nexport STEPUP_SYNC_RPC_TIMEOUT=\"30\"\n</code></pre> <p>Finally, run the following commands:</p> <pre><code>direnv allow\npip install -U pip\npip install -e .[dev]\npip install -e ../stepup-core[dev] --config-settings editable_mode=strict  # optional\n</code></pre>"},{"location":"development/#tests","title":"Tests","text":"<p>We use pytest, so you can run the tests as follows:</p> <pre><code>pytest -vv\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentation is created with MkDocs.</p> <p>Edit the documentation markdown files with a live preview by running:</p> <pre><code>mkdocs serve\n</code></pre> <p>(Keep this running.) Then open the live preview in your browser: http://127.0.0.1:8000/ and edit Markdown files in your IDE.</p> <p>Please, use Semantic Line Breaks because it results in cleaner file diffs when editing documentation.</p>"},{"location":"development/#how-to-make-a-release","title":"How to Make a Release","text":"<ul> <li>Mark the release in <code>changelog.md</code>.</li> <li>Make a new commit and tag it with <code>vX.Y.Z</code>.</li> <li>Trigger the PyPI GitHub Action: <code>git push origin main --tags</code>.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>The installation instructions are listed here for completeness.</p> <p>If you are new to StepUp RepRep, we recommend that you follow the Template Tutorial instead. One of the steps in that tutorial is to install StepUp RepRep in a suitable virtual environment.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>POSIX operating system: Linux, macOS or WSL.   StepUp cannot run natively on Windows.</li> <li>Python \u2265 3.11</li> <li>Pip</li> </ul> <p>It is assumed you know how to use Pip. We recommend performing the installation in a Python virtual environment and activating such environments with direnv.</p>"},{"location":"installation/#minimal-installation","title":"Minimal installation","text":"<p>The RepRep extension (for reproducible reporting) is installed with:</p> <pre><code>pip install stepup-reprep\n</code></pre> <p>(This will also install StepUp Core.)</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#source-code-license","title":"Source code license","text":"<p>StepUp RepRep is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>StepUp RepRep is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.</p>"},{"location":"license/#documentation-license","title":"Documentation license","text":"<p>StepUp RepRep\u2019s documentation is distributed under the Creative Commons CC BY-SA 4.0 license.</p>"},{"location":"advanced_topics/archive_git/","title":"Archive a Git Repository (of a StepUp project)","text":""},{"location":"advanced_topics/archive_git/#git-repositories-versus-long-term-archival","title":"Git Repositories Versus Long-term Archival","text":"<p>You may consider your online Git provider (GitHub, GitLab, \u2026) as an archival solution, for example, for datasets and publication source files. Indeed, these services have proven to be dependable over the last decade. However, their reliability alone does not make them suitable for long-term archival:</p> <ul> <li> <p>An online Git platform is typically provided by a single company.   While these companies are unlikely to vanish any time soon,   they have no legal obligation to preserve your data.   (Of course, in practice, they do a great job at keeping their servers up and running.)</p> </li> <li> <p>Git repositories are editable by design.   You can even accidentally wipe them entirely with a single <code>git push -f</code> command.   For long-term storage, a static deposition of files is preferable.</p> </li> <li> <p>Online Git platforms and their Large File Storage (LFS) backends have a limited capacity.   If you exceed your data quota, you will have to pay up or clean up.</p> </li> <li> <p>A Git repository primarily stores (text-based) source files,   not the output derived from those source files.   With StepUp, you can easily regenerate all results and PDFs from these sources,   so storing them in Git is not strictly necessary.   It may also be undesirable to store output files in Git due to storage and bandwidth limitations.   As a result, output is generally not archived in a Git repository.</p> <p>This is not a problem while you are working on a publication, as you are constantly using StepUp (or another tool) to build the outputs. However, if you are taking data from an old archive, regenerating the output from the sources can be a challenge. For example, after 10 years the required software may not be readily available or compatible with your current operating system. In such a scenario, it is preferable to also include all output in the archive.</p> </li> </ul>"},{"location":"advanced_topics/archive_git/#preparations-when-using-git-lfs","title":"Preparations When Using Git LFS","text":"<p>Git LFS makes it easier to work with large files, but it also complicates the archiving process. LFS improves the efficiency of Git by storing large files externally, so that when you clone a Git repository, you don\u2019t have to download all versions of those large files. Instead, LFS will only download the versions of the large files that you are working on.</p>"},{"location":"advanced_topics/archive_git/#download-large-files-from-lfs","title":"Download Large Files from LFS","text":"<p>If you just want to download and check out the large files in the current Git commit, run:</p> <pre><code>git lfs pull\n</code></pre> <p>If you want to archive all versions of the large files, you will need to explicitly tell LFS to download them all. This can take a long time and consume a lot of resources, so think twice. If you are sure you want to do this, download all files as follows:</p> <pre><code>git lfs fetch --all\n</code></pre> <p>Some large files in your working directory may still be LFS file pointers after the <code>fetch</code> command. To replace these pointers with the actual files, run:</p> <pre><code>git lfs checkout\n</code></pre>"},{"location":"advanced_topics/archive_git/#migrate-from-an-lfs-enabled-git-repository","title":"Migrate from an LFS-enabled Git Repository","text":"<p>If you want to archive the entire history including the large files, you will need to migrate your Git repository back to a normal one without LFS. This is relevant if you want to use the <code>git bundle</code> tool discussed below, as it is incompatible with LFS.</p> <p>This migration will make your clone incompatible with the remote repository. The migration is also not easily reversible. So plan this step carefully, and make sure you really want to do this before you proceed.</p> <p>The migration can be performed in two steps:</p> <ol> <li> <p>Get some information on LFS migration before starting:</p> <pre><code>git lfs migrate info --everything\n</code></pre> </li> <li> <p>Perform the actual migration:</p> <pre><code>git lfs migrate export --everything --include=\"*.*\"\n</code></pre> </li> </ol>"},{"location":"advanced_topics/archive_git/#archival-recipes","title":"Archival Recipes","text":"<p>The subsections below show how to archive a Git repository in different ways. Depending on your use case, you may want to combine several archiving methods. For example, compact archives may be preserved over longer times than larger ones.</p> <p>Note: Work in the Git root</p> <p>All the commands below should be run from the root directory of your Git repository. Archives created using the instructions below will be added to this directory, and will need to be uploaded or moved to a long-term storage. (The details of the long-term storage are beyond the scope of this tutorial.)</p>"},{"location":"advanced_topics/archive_git/#archive-the-source-history","title":"Archive the Source History","text":"<p>Warning: <code>git bundle</code> archives LFS pointers, not large files.</p> <p>If your repository contains Git LFS objects, <code>git bundle</code> will archive the file pointers instead of the large files. If you want to include the large files in the bundle, you must first migrate from an LFS-enabled repository to a normal one, as explained above.</p> <p>The following command will archive the entire history of the source files in the Git repository:</p> <pre><code>git bundle create main.bundle main\n</code></pre> <p>It is recommended that you use a more descriptive name than <code>main.bundle</code>. The bundle file will contain the entire history of the <code>main</code> branch and some metadata stored under <code>.git/</code>. You can specify additional branches. For more details on bundles, see the Git bundle documentation.</p> <p>If you want to recreate a Git repository from a bundle, run:</p> <pre><code>git clone main.bundle\n</code></pre>"},{"location":"advanced_topics/archive_git/#archive-source-files-from-the-latest-commit","title":"Archive Source Files from the Latest Commit","text":"<p>There are two options, the latter of which is preferable:</p> <ol> <li> <p>You can create a Git bundle with a single commit,    which is subject to the same LFS considerations mentioned above:</p> <pre><code>git bundle create main.bundle -1 main\n</code></pre> </li> <li> <p>You can create a ZIP file containing all the source files    using StepUp RepRep\u2019s Inventory Files:</p> <ul> <li> <p>Make sure that the working tree is clean.   The <code>git status</code> command should print   <code>nothing to commit, working tree clean</code>.</p> </li> <li> <p>Write an <code>inventory-main.def</code> file with the following line,   to include all files recorded by Git:</p> <pre><code>include-git\n</code></pre> </li> <li> <p>Create an <code>inventory-main.txt</code> file of the entire source tree,   using the following command in the terminal:</p> <pre><code>rr-make-inventory -i inventory-main-latest.def\n</code></pre> <p>This will write a complete listing to <code>inventory-main.txt</code></p> </li> <li> <p>Then create a (reproducible) ZIP file from the <code>.txt</code> file   by running the following command:</p> <pre><code>rr-zip-inventory inventory-main-latest.txt main-latest.zip\n</code></pre> </li> </ul> </li> </ol>"},{"location":"advanced_topics/archive_git/#archiving-source-and-output-files-from-the-last-commit","title":"Archiving Source and Output Files from the Last Commit","text":"<p>This is similar to the previous section, but now with a larger set of files. Create an <code>inventory-main-latest-with-outputs.def</code> file that will include all files recorded by Git and all outputs of the StepUp workflows:</p> <pre><code>include-git\ninclude-workflow BUILT */.stepup/workflow.mpk.gz\n</code></pre> <p>(It is assumed that all STATIC files are already checked into the Git repository.) With this file, just follow the same steps as in option 2 of the previous subsection.</p>"},{"location":"advanced_topics/archive_git/#create-a-readmemd-for-the-archives","title":"Create a <code>README.md</code> for the Archives","text":"<p>Archives created using the instructions above must be accompanied by a <code>README.md</code> file that includes the following:</p> <ul> <li> <p>A brief overview of the archive files and a few sentences  about their contents.   The archive file itself should also contain a top-level <code>README.md</code> file,   to refer to for more details.</p> </li> <li> <p>An explanation of how the archives were created and how to use or unpack them.   You can copy and paste from this documentation and modify it as needed.</p> </li> </ul>"},{"location":"advanced_topics/bibsane/","title":"Sanitizing BibTeX files","text":"<p>Note</p> <p>Bibsane is integrated into StepUp RepRep as of version 2.3.</p> <p>StepUp RepRep can clean up BibTeX files to fix issues that would otherwise be difficult to spot or require tedious manual edits. This feature was formerly implemented in an external tool called <code>bibsane</code>, but is now integrated into StepUp RepRep. The cleanup must always be performed after building the LaTeX document, to be able to identify unused records.</p> <p>The following is a minimal example of the commands in a <code>plan.py</code> file that will clean up a BibTeX file:</p> <pre><code>from stepup.core.api import static\nfrom stepup.reprep.api import compile_latex, sanitize_bibtex\n\nstatic(\"paper.tex\", \"references.bib\")\ncompile_latex(\"paper.tex\")\nsanitize_bibtex(\"paper.aux\")\n</code></pre> <p>The <code>sanitize_bibtex()</code> function will read the <code>.aux</code> file(s) to identify the <code>.bib</code> files used. By default, it assumes there is just one <code>.bib</code> file and rewrites it with the cleaned-up content. If there are multiple <code>.bib</code> files, you can specify an output file with <code>path_out=\"clean.bib\"</code>.</p> <p>The <code>sanitize_bibtex()</code> function also accepts a <code>path_cfg</code> argument to specify a YAML configuration file for <code>rr-bibsane</code>, i.e. the script that actually implements the cleanup. (Without configuration file, a minimal cleanup is performed.) For example, you can create a <code>bibsane.yml</code> file with the following content to enable more checks and cleanups:</p> <pre><code>drop_entry_types: [\"control\"]\nnormalize_doi: true\nduplicate_id: merge  # other options: fail or ignore\nduplicate_doi: merge  # other options: fail or ignore\npreambles_allowed: false\nnormalize_whitespace: true\nfix_page_double_hyphen: true\n# PyISO4 can be used to abbreviate journal names.\nabbreviate_journal: true\ncustom_abbreviations:\n    CRAZY J0rnAL: Crazy J.\nsort: true  # sort key = {year}{first author lowercase normalized name}\ncitation_policies:\n  article:\n    author: must\n    journal: must\n    number: may\n    pages: must\n    title: must\n    volume: must\n    year: must\n    doi: must\n  book:\n    author: must\n    title: must\n    publisher: must\n    year: must\n    month: must\n    isbn: must\n  misc.url:\n    title: must\n    url: must\n    urldate: must\n  misc.dataset:\n    author: must\n    title: must\n    year: must\n    doi: must\n    urldate: must\n    publisher: must\n</code></pre> <p>Everything above <code>citation_policies</code> consists of global settings. See <code>BibsaneConfig</code> for a full list of available settings.</p> <p>Under <code>citation_policies</code> you can specify which keys are expected and allowed for each entry type. The <code>misc</code> entry type is a catchall for diverse citations, so you can specify subtypes like <code>misc.url</code> and <code>misc.dataset</code>. In your BibTeX file, you can identify the subtype by adding a <code>bibsane</code> field. For example:</p> <pre><code>@misc{doe2025,\n author = {John Doe},\n bibsane = {misc.dataset},\n doi = {10.5281/zenodo.0123456},\n publisher = {Zenodo},\n title = {Some data set, Version 1},\n urldate = {2025-02-12},\n year = {2025}\n}\n</code></pre>"},{"location":"advanced_topics/good_practices/","title":"Good practices","text":""},{"location":"advanced_topics/good_practices/#good-practices","title":"Good Practices","text":"<p>This tutorial lists some recommendations to facilitate data accuracy, reuse and reproducibility when working on a StepUp RepRep project.</p> <p>The first section contains a compact summary of the recommendations, and refer to parts of the second section for more background and motivation behind the recommendations.</p>"},{"location":"advanced_topics/good_practices/#summaries","title":"Summaries","text":"<p>The summaries below are grouped into categories, and within each category, there are two classes of recommendations:</p> <ul> <li>\u201cMust\u201d recommendations are highly encouraged.   Even if you initially neglect some of these recommendations,   you would benefit from converting your repository to comply with them.</li> <li>\u201cShould\u201d recommendations are also encouraged but are considered less urgent.   There may be external factors, such as a publisher, that force you to deviate.</li> </ul>"},{"location":"advanced_topics/good_practices/#filename-conventions","title":"Filename Conventions","text":""},{"location":"advanced_topics/good_practices/#must","title":"Must","text":"<ul> <li>Use semantic file and directory names to organize your data.</li> <li> <p>If directory or file names contain numbers,   zero-pad them so that all relevant information is nicely aligned   and file names are sorted correctly.</p> <p>Good example:</p> <pre><code>pressure-000.1MPa.txt\npressure-001.0MPa.txt\npressure-010.0MPa.txt\npressure-100.0MPa.txt\n</code></pre> <p>Bad example:</p> <pre><code>pressure-0.1MPa.txt\npressure-100.0MPa.txt\npressure-10.0MPa.txt\npressure-1.0MPa.txt\n</code></pre> </li> <li> <p>Similarly, keywords can be padded with dashes or underscores, for instance:</p> <pre><code>opt__low\nopt_high\n</code></pre> </li> <li> <p>If you use a similar structure within multiple directories,   use exactly the same file names within the directories.   This facilitates automation.</p> <p>Good example:</p> <pre><code>opt__low/compute.py\nopt_high/compute.py\n</code></pre> <p>Bad example:</p> <pre><code>opt__low/compute__low.py\nopt_high/compute_high.py\n</code></pre> <p>Terrible example:</p> <pre><code>opt__low/compute.py\nopt_high/calculate.py\n</code></pre> </li> </ul>"},{"location":"advanced_topics/good_practices/#tex-sources","title":"Tex Sources","text":""},{"location":"advanced_topics/good_practices/#must_1","title":"Must","text":"<ul> <li>All documents are written in LaTeX.</li> <li>Any unused LaTeX package is a good package.</li> <li>Each sentence starts on a new line in the LaTeX source.</li> <li>Use single-column and double-line spacing to make the PDF easier to review.</li> <li>Use BibSane to clean up your BibTeX files.   Hint: Quick DOI to BIB conversion</li> <li>Avoid <code>\\subfigure</code>. Instead, merge panels into one PDF. (See Tile PDFs.)</li> </ul>"},{"location":"advanced_topics/good_practices/#should","title":"Should","text":"<ul> <li>Some packages, such as <code>todo</code>, are useful while drafting a manuscript.   Separate these clearly from other <code>\\usepackage</code> lines,   so that they can be easily deleted when the manuscript is finished.</li> <li>Define as few custom commands as possible.</li> <li>Avoid using low quality publisher article classes.   (ACS has a decent one.)</li> </ul>"},{"location":"advanced_topics/good_practices/#figures","title":"Figures","text":""},{"location":"advanced_topics/good_practices/#must_2","title":"Must","text":"<ul> <li> <p>Separate data generation or collection from actual plotting:   Perform these two steps in separate Python scripts.   This means committing the following to Git:</p> <ul> <li> <p>Data files (e.g., CSV) containing plot data, including generated data.   This allows for verification of reproducibility.</p> </li> <li> <p>Scripts that generate the data, if applicable.</p> </li> <li> <p>Scripts that generate the plots using the above data as input.   Use matplotlib unless otherwise justified.</p> </li> <li> <p>A <code>README.md</code> or docstrings summarizing the scripts and data.</p> </li> </ul> </li> <li> <p>Use Inkscape (&gt;= 1.2) to create drawings and commit SVG source files.</p> </li> <li> <p>Use bitmap formats only as an intermediate format   when vector graphics PDFs show performance problems.   This is typically the case for plots with many thousands of data points:   Use high-resolution PNG files (not GIF, JPEG or other formats).</p> </li> <li> <p>Avoid using Jupyter Notebooks as a tool for creating plots.</p> </li> </ul>"},{"location":"advanced_topics/good_practices/#tables","title":"Tables","text":""},{"location":"advanced_topics/good_practices/#must_3","title":"Must","text":"<p>Commit the following to the Git history:</p> <ul> <li>Machine-readable files, such as CSV, containing table data.</li> <li>Scripts that generate LaTeX source for the tables.</li> <li>A <code>README.md</code> or docstrings summarizing the scripts and data.</li> <li>Avoid using Jupyter Notebooks as a tool for creating tables.</li> </ul>"},{"location":"advanced_topics/good_practices/#data-sets","title":"Data Sets","text":""},{"location":"advanced_topics/good_practices/#must_4","title":"Must","text":"<ul> <li> <p>Use <code>dataset-{name}</code> directories for data that cannot (easily) be generated from scratch.   For example:</p> <ul> <li>External datasets.</li> <li>Expensive calculations.</li> <li>(Large amounts of) experimental measurements.</li> <li>Data generated with closed-source software.   (Avoid closed-source software when you have the choice.)</li> <li>Data created with specialized hardware that is not generally available.</li> <li>Manually curated data.</li> </ul> </li> <li> <p>Add scripts and implementations to regenerate the data,   integrating them as much as possible with StepUp RepRep.</p> </li> <li> <p>Add a <code>README.md</code> file that explains:</p> <ul> <li>How the data was generated.</li> <li>The software that was used.</li> <li>Directory and file organization.</li> <li>File content details.</li> </ul> </li> <li> <p>Datasets are Zipped in the end, so store uncompressed data in the repository.</p> </li> <li> <p>Avoid using Jupyter Notebooks as a tool for working with datasets.</p> </li> <li> <p>Do not invent your own file formats.</p> </li> <li> <p>Do not use tar files, especially compressed ones, due to data loss concerns.   ZIP is more robust, because each file is compressed individually.</p> </li> <li> <p>Do not use HDF5 files because of data integrity issues.</p> </li> <li> <p>Do not use Python pickle files,   as they can only be loaded when the corresponding Python packages are available.   This is too restrictive for long-term data preservation.</p> </li> <li> <p>Do not use file formats that can only be used with closed source software.</p> </li> </ul>"},{"location":"advanced_topics/good_practices/#should_1","title":"Should","text":"<ul> <li> <p>For files larger than exceed 500 kB, use Git LFS,   instead of committing them directly into the Git repository.   The threshold can be increased for convenience,   but be aware of the storage quota of the remote Git repository.   For GitHub, the maximum currently appears to be 5 GB (for the entire history).</p> </li> <li> <p>When datasets become large for Git LFS,   collect the data on a remote server that all co-authors can access.   Check your Git LFS quota to determine a reasonable threshold.   At the time of writing, this is 2 GB (all files combined) for GitHub.   If you store data outside of the Git repository,   clearly document where the data is stored,   how it can be accessed and who has access permissions.</p> </li> <li> <p>For some files, such as zipped collections of data files,   there is no concern that the zipping itself will be difficult to reproduce,   so you can add such files to <code>.gitignore</code>.</p> </li> <li> <p>Do not put compressed files inside compressed files.   This is usually inefficient and increases the risk of large data losses due to bitrot.</p> </li> <li> <p>Avoid binary files in general, as they are harder to reuse in the longer term.</p> </li> </ul>"},{"location":"advanced_topics/good_practices/#software","title":"Software","text":""},{"location":"advanced_topics/good_practices/#must_5","title":"Must","text":"<ul> <li> <p>List software dependencies in <code>requirements.txt</code> or <code>environment.yaml</code>,   and pin the version of the requirements to a specific version.   This allows co-authors to install the same software using <code>pip</code> or <code>conda</code>.</p> </li> <li> <p>If you are using <code>pip</code>, prepare a <code>requirements.in</code> file   and convert it using <code>pip-compile</code> to a <code>requirements.txt</code> file.   See pip-tools for more details.</p> </li> <li> <p>Use only open source software to (re)build the publication.</p> </li> <li> <p>If possible, avoid using closed source software altogether.</p> </li> <li> <p>If you do generate some data with closed-source software,   put it in a <code>dataset-&lt;name&gt;</code> directory   and document in the <code>README.md</code> how exactly you generated the data   and what versions of the software were used.</p> </li> <li> <p>If you write your own Python package and use it in a publication,   make open source releases of all versions used in the paper.   In addition to <code>requirements.txt</code> or <code>environment.yaml</code>,   refer to the source repository and the version of your package in the <code>README.md</code>   of the corresponding <code>results-&lt;name&gt;</code> or <code>dataset-&lt;name&gt;</code> directories.</p> <p>If your Python package is experimental and not yet ready for release, include it in the publication project repository under <code>latest-draft/pkgs/your_package</code>. Add a line <code>-e latest-draft/pkgs/your_package</code> to the <code>requirements.txt</code> and <code>environment.yaml</code> files as follows:</p> <p>requirements.txt (just add a line)</p> <pre><code>-e latest-draft/pkgs/your_package\n</code></pre> <p>environment.yaml (add a line under the <code>pip</code> item)</p> <pre><code>- pip:\n- '-e latest-draft/pkgs/your_package'\n</code></pre> </li> </ul>"},{"location":"advanced_topics/good_practices/#details","title":"Details","text":"<p>This section provides additional background information on the recommendations listed above. Note that this section is still a work in progress.</p>"},{"location":"advanced_topics/good_practices/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>Jupyter Notebooks are very popular for interactive Python programming because you can combine documentation, code, and visualization in one document. However, Jupyter Notebooks have also been criticized for encouraging bad practices. In short, notebooks have inherent limitations that are not easy to overcome:</p> <ul> <li>Changes to Jupyter Notebooks are not easily visualized with textual diffs.</li> <li>Related to the previous point:   Collaborating on Jupyter Notebooks via version control is problematic.   Merging different contributions to notebooks easily leads to invalid PYNB files.</li> <li>You can execute code cells in notebooks in any order, which can lead to incorrect results.</li> <li>You cannot easily import Jupyter Notebooks into other notebooks,   making them non-modular and monolithic.   The only way to reuse code from one notebook in another is to copy and paste fragments.</li> </ul> <p>For these reasons, we recommend avoiding them and instead working with reproducible workflows that combine scripts and analysis tools implemented in Python modules (or packages) and Markdown files.</p> <p>StepUp addresses the above issues as follows:</p> <ul> <li>Python source code is implemented in simple Python files,   so the output <code>git diff</code> is readable and merging is relatively easy.</li> <li>StepUp\u2019s script protocol   allows you to specify the inputs and outputs of each script   so that StepUp executes them in the correct order.</li> <li>If you change one or more scripts, StepUp will determine which scripts need to be re-executed,   as opposed to manually re-executing cells in notebooks (which is error-prone).</li> <li>If you want to create simple reports that integrate your comments, results and figures,   you can write Markdown files with figures and convert them to PDF using   <code>convert_markdown()</code>   and <code>convert_weasyprint()</code>.</li> </ul>"},{"location":"advanced_topics/good_practices/#hdf5","title":"HDF5","text":"<p>If a process is killed while writing to an HDF5 file, there is a tiny chance that the entire file will become unreadable, not just the part that was being written. Such an abrupt process termination can never be ruled out (e.g., power failure). We are not aware of any recent fixes for this, e.g., some form of journaling may make the format resilient to interrupted writes. This happens so rarely that the issue is often dismissed as irrelevant, see https://news.ycombinator.com/item?id=10860496</p> <p>Zarr is an alternative to HDF5 that has comparable features but does not have the catastrophic data loss issue because it writes different arrays to different files. It relies on the robustness of journaling at the file system level, and so does not need to reimplement it at the file format level. Zarr does not support some of the extreme performance features of HDF5, just to say that nothing is perfect. Still, reliability beats performance, because losing data is a waste of time.</p> <p>For less demanding applications, NumPy\u2019s NPY and NPZ may be a good fit. Their main advantage is the simplicity and availability within NumPy.</p> <p>Some online discussions on the subject:</p> <ul> <li>2018: https://forum.hdfgroup.org/t/avoiding-corruption-of-the-hdf5-file/4087</li> <li>2022: https://forum.hdfgroup.org/t/corrupted-file-due-to-shutdown/9658</li> <li>2022: https://janert.me/blog/2022/looking-at-hdf5/</li> </ul>"},{"location":"advanced_topics/inventory_files/","title":"Inventory Files","text":"<p>StepUp RepRep uses <code>inventory.txt</code> to collect metadata to prepare a ZIP archive. Inventory files can either be created manually (for an external dataset) or automatically (for datasets created within a StepUp workflow.)</p>"},{"location":"advanced_topics/inventory_files/#file-formats","title":"File Formats","text":""},{"location":"advanced_topics/inventory_files/#inventory-files-inventorytxt","title":"Inventory Files (<code>inventory.txt</code>)","text":"<p>The <code>inventory.txt</code> file contains one line per file to be archived. Each line has four fields:</p> <ul> <li>the file size,</li> <li>the file mode,</li> <li>the BLAKE2b hash   of the file contents (regular file) or link destination (symbolic link), and</li> <li>the relative path to the file, starting from the parent of the inventory file.</li> </ul> <p>A fixed column width is used. You do not create this type of file manually. Instead, StepUp RepRep offers tools to make such files. (See below.)</p>"},{"location":"advanced_topics/inventory_files/#inventory-definitions-inventorydef","title":"Inventory Definitions (<code>inventory.def</code>)","text":"<p>The <code>inventory.def</code> format is inspired by the <code>MANIFEST.in</code> format from the setuptools project. As of version 1.2.0, StepUp RepRep no longer relies on setuptools and has its own implementation to process inventory definitions.</p> <p>Inventory definition files are processed one line at a time. Comments start with the <code>#</code> character, just as in Python source code. Empty lines or lines containing only comments are ignored. A Non-empty line must contain one command starting with <code>include</code> or <code>exclude</code>. Each command first generates a new list of paths. An <code>include</code> command will add the newly generated paths to the inventory, whereas an <code>exclude</code> command will remove them from the inventory (if present). Each command operates on the file list constructed by preceding commands. (The first command starts from an empty list.)</p> <p>The following rules are supported:</p> <ul> <li>A bare <code>include</code> or <code>exclude</code> is followed by one or more   Named Glob patterns,   which may also contain <code>**</code> wildcards to match files recursively.</li> <li>The <code>include-git</code> and <code>exclude-git</code> use <code>git ls-files</code> to generate a list of files.   Arguments to this command are optional and are passed to <code>git ls-files</code>.</li> <li>The <code>include-workflow</code> and <code>exclude-workflow</code> extract a file list   from one or more StepUp <code>graph.db</code> files.   The first argument is the state of the files to be selected.   (<code>STATIC</code> or <code>BUILT</code> are common. Other states exist but make less sense.)   All subsequent arguments are (Named Glob patterns matching) StepUp <code>graph.db</code> files.</li> </ul> <p>If any of these rules produces directories, they will not be included in the inventory. An exception is raised when no matching paths are found.</p>"},{"location":"advanced_topics/inventory_files/#creating-inventorytxt-files","title":"Creating <code>inventory.txt</code> Files","text":""},{"location":"advanced_topics/inventory_files/#command-line-tool-stepup-make-inventory","title":"Command-line Tool <code>stepup make-inventory</code>","text":"<p>One can create an inventory file on the command-line as follows:</p> <pre><code>stepup make-inventory -i inventory.def -o inventory.txt\n</code></pre> <p>See <code>stepup make-inventory --help</code> for more details. This tool is suitable for creating inventory files of external datasets.</p>"},{"location":"advanced_topics/inventory_files/#stepup-reprep-function-make_inventory","title":"StepUp RepRep Function <code>make_inventory</code>","text":"<p>One may include a <code>make_inventory()</code> step in <code>plan.py</code> as follows:</p> <pre><code>from stepup.reprep.api import make_inventory\n\nmake_inventory(\"file1.txt\", \"file2.txt\", \"inventory.txt\")\n</code></pre> <p>This step is mainly useful for creating an inventory file of a dataset generated by your StepUp workflow. It can also be combined with <code>stepup.core.glob</code> for building datasets from static files, or one may provide an inventory definition files as follows:</p> <pre><code>from stepup.reprep.api import make_inventory\n\nmake_inventory(\"inventory.txt\", path_def=\"inventory.def\")\n</code></pre>"},{"location":"advanced_topics/inventory_files/#creating-a-zip-archive-from-a-inventorytxt-file","title":"Creating a ZIP Archive From a <code>inventory.txt</code> File","text":""},{"location":"advanced_topics/inventory_files/#command-line-tool-stepup-zip-inventory","title":"Command-line Tool <code>stepup zip-inventory</code>","text":"<p>Given an <code>inventory.txt</code> file, the corresponding ZIP file is created with:</p> <pre><code>stepup zip-inventory inventory.txt\n</code></pre> <p>This is a command-line wrapper around the <code>zip_inventory</code> function discussed below.</p>"},{"location":"advanced_topics/inventory_files/#stepup-reprep-function-zip_inventory","title":"StepUp RepRep Function <code>zip_inventory</code>","text":"<p>The function <code>zip_inventory()</code> takes a <code>inventory.txt</code> file as input and creates a ZIP file containing all the files listed in the inventory. It differs from the conventional <code>zip</code> program in the following ways:</p> <ul> <li>File hashes are checked before adding files to the archive,   which is mostly useful for external datasets.</li> <li>The <code>inventory.txt</code> file is included in the resulting ZIP file.</li> <li>The ZIP file is reproducible: all time stamps in the ZIP file are set to January 1st, 1980.</li> <li>By default, symbolic links are added as links, instead of the contents they point to.</li> </ul>"},{"location":"advanced_topics/inventory_files/#unpacking-the-zip-file","title":"Unpacking the ZIP file","text":"<p>To unpack the ZIP file, use the following command:</p> <pre><code>unzip inventory.zip\n</code></pre> <p>This will correctly handle symbolic links, unlike Python\u2019s built-in extractall method. See cpython#82102 for more details on Python\u2019s (lacking) support for symbolic links in ZIP files.</p>"},{"location":"advanced_topics/inventory_files/#validate-an-inventory-file","title":"Validate an Inventory File","text":"<p>If you just want to check the file sizes, modes and hashes of an inventory, run:</p> <pre><code>stepup check-inventory inventory.txt\n</code></pre> <p>This can be useful in the following cases:</p> <ul> <li>When you work with a remote dataset, you can check if the files in the inventory have changed.</li> <li>When you unpack a ZIP file created <code>stepup zip-inventory</code> or <code>zip_inventory()</code>,   you can check if the files are not affected by bit rot or other data integrity issues.</li> </ul>"},{"location":"advanced_topics/sync_zenodo/","title":"Upload a dataset to Zenodo","text":"<p>Version history</p> <p>This feature was added to StepUp RepRep 1.3.</p> <p>StepUp RepRep can create a draft dataset in Zenodo on your behalf, and automatically update it when the local versions of your files have changed. You can also provide metadata within your StepUp project, which minimizes the amount of GUI interaction required in the Zenodo web interface. This approach also makes it easier for all your collaborators to review and contribute to the (meta)data before the dataset is published on Zenodo.</p> <p>You will still need to use the Zenodo web interface to publish the dataset. If your files change and you want to create a new version, you must increment the version numbers using the semantic version numbering format.</p>"},{"location":"advanced_topics/sync_zenodo/#configure-a-zenodo-dataset","title":"Configure a Zenodo dataset","text":"<p>To prepare a dataset, you need to create a <code>zenodo.yaml</code> file by filling in the following template:</p> <pre><code>path_versions: .zenodo-versions.json\nendpoint: https://sandbox.zenodo.org/api\npath_token: ~/.config/sandbox-zenodo-org-token.txt\nmetadata:\n  title: 'A title'\n  version: '1.0.0'\n  license: cc-by-nc-4.0\n  upload_type: dataset\n  creators:\n    - name: 'Last name 1, First name 1'\n      affiliation: &gt;-\n        Research group,\n        University,\n        Street and number,\n        ZIP code\n        City,\n        Country\n      orcid: '0000-0002-1825-0097'\n    - name: 'Last name 2, First name 2'\n      affiliation: &gt;-\n        Research group,\n        University,\n        Street and number,\n        ZIP code\n        City,\n        Country\n      orcid: '0000-0002-1825-0098'\n    - ...\npath_readme: zenodo.md\npaths:\n  - file1\n  - sub/file2\n</code></pre> <p>Documentation of the fields in the <code>zenodo.yaml</code> configuration file:</p> <ul> <li> <p><code>path_versions</code>:   A JSON file containing all versions of the dataset in chronological order   and their corresponding record IDs.   This file is updated by the <code>stepup sync-zenodo</code> script.   You should not need to modify it unless you created or discarded new records   manually through the Zenodo web interface.   It is recommended to commit this file to the Git history.</p> </li> <li> <p><code>endpoint</code>:   If you want to test the upload without using the production Zenodo platform,   use the sandbox endpoint.   Remove the <code>sandbox.</code> prefix for production uploads.</p> </li> <li> <p><code>path_token</code>:   The location of a text file with your Zenodo (sandbox) personal access token.   If the token file is not present,   the plan.py below will validate this file without uploading.</p> <p>To create the token, go to the settings of your Zenodo account or Zenodo Sandbox account. Enable the <code>deposit:actions</code> and <code>deposit:write</code> scopes when creating a new token. Save the token immediately, as it cannot be retrieved later.</p> </li> <li> <p><code>metadata</code>:   A section with metadata fields to describe the dataset on Zenodo.</p> <ul> <li><code>title</code>:   A short description of the dataset.</li> <li> <p><code>version</code>:   The version of your current data.</p> <p>Put the version number in quotes to prevent it from being interpreted as a floating-point number. Use semantic version numbers.</p> <p>If you have published the dataset, only metadata of the published versions can be updated, but not the files. If you want to upload newer files, you can increment this version number. The <code>stepup sync-zenodo</code> script will create a new version for you on Zenodo, which stays in draft mode until you manually publish it through the Zenodo web interface.</p> </li> <li> <p><code>license</code>:   Lowercase license SPDX identifier.   The list of licenses supported by Zenodo (and their identifiers)   can be found in SPDX License list.</p> </li> <li> <p><code>upload_type</code>   Select one of:   <code>publication</code>, <code>poster</code>, <code>presentation</code>, <code>dataset</code>, <code>image</code>,   <code>video</code>, <code>software</code>, <code>lesson</code>, <code>physicalobject</code>, or <code>other</code>.</p> </li> <li> <p><code>creators</code>:   List one or more creators of the data.</p> <ul> <li><code>name</code>:   The full name of a creator.   Format this field as <code>Last name, First name</code></li> <li><code>affiliation</code>   The full address including affiliation.</li> <li><code>orcid</code>:   The ORCID of the creator.   Format this field as <code>0000-0002-1825-0097</code>.   (This field is optional, but recommended.)</li> </ul> </li> </ul> </li> <li> <p><code>path_readme</code>:   This field is optional.   If given, the Markdown file will be converted to HTML and used as description metadata.   Alternatively, you can add a <code>description</code> field with an HTML value to the metadata.</p> </li> <li> <p><code>paths</code>:   The dataset files to be uploaded.</p> <p>Zenodo does not support subdirectories, so files are uploaded without reference to their parent directory. This also means that two files with the same name in different subdirectories cannot both be included. If you have such files or if you have a large number of files, consider uploading a ZIP archive instead of separate files.</p> </li> </ul>"},{"location":"advanced_topics/sync_zenodo/#synchronize-your-dataset","title":"Synchronize your dataset","text":"<p>The command <code>stepup sync-zenodo</code> will create or synchronize the online dataset and store the <code>record_id</code> in the versions JSON file. This way, future calls will update this record instead of creating a new dataset on Zenodo.</p> <p>Once you have all the files you need, execute the script:</p> <pre><code>stepup sync-zenodo zenodo.yaml\n</code></pre> <p>You can also include this command as a step in your <code>plan.py</code> file:</p> <pre><code>from stepup.core.api import static\nfrom stepup.reprep.api import sync_zenodo\n\nstatic(\"zenodo.yaml\", \"zenodo.md\", \"file1\", \"sub/\", \"sub/file2\")\nsync_zenodo(\"zenodo.yaml\")\n</code></pre>"},{"location":"advanced_topics/sync_zenodo/#try-the-following","title":"Try the Following","text":"<p>When creating a publication starting from the RepRep Template Tutorial, one can use the <code>sync_zenodo()</code> function to continuously synchronize the latest version of a publication with co-authors. Drafts of datasets can be shared with co-authors, in this case to give them access to the most recent build of the publication PDFs.</p>"},{"location":"advanced_topics/sync_zenodo/#known-limitations","title":"Known limitations","text":"<ul> <li>Funding information cannot be included in the YAML config file yet.   The Zenodo API documentation still needs to be written to support this feature.   See zenodo/zenodo#950.   (The corresponding documentation for the Web interface does not exist either.)   Also, adding funding details manually does not seem to work yet,   because not all funding organizations are included.   For now, just add funding details to the dataset description.</li> <li>The Zenodo API does not support multiple affiliations.   See zenodo/zenodo#1608</li> <li>Not all Zenodo metadata fields are supported.   We may add more in future versions of StepUp RepRep.</li> </ul>"},{"location":"advanced_topics/tile_pdfs/","title":"Tile PDFs","text":"<p>StepUp RepRep includes a tool to tile panels (individual PDF figures) into a composite PDF figure.</p> <p>The tiling code is based on the script protocol in StepUp Core, which is explained in the StepUp Core \u201cGetting Started\u201d tutorials.</p> <p>This tutorial provides a simple example that you can use as a starting point. For a more advanced example, see the <code>tile_pdf</code> test case in the StepUp RepRep unit test suite.</p>"},{"location":"advanced_topics/tile_pdfs/#example","title":"Example","text":"<p>Example source files: advanced_topics/tile_pdfs/</p> <p>Create a <code>tile.py</code> script with the following code:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.script import driver\nfrom stepup.reprep.tile_pdf import Figure, Panel\n\nFIGURE = Figure(\n    \"figure.pdf\",\n    [\n        Panel(0, 0, \"(a) triangle\", \"triangle.pdf\"),\n        Panel(0, 1, \"(b) square\", \"square.pdf\"),\n        Panel(1, 0, \"(c) pentagon\", \"pentagon.pdf\"),\n        Panel(1, 1, \"(d) hexagon\", \"hexagon.pdf\"),\n    ],\n)\n\nif __name__ == \"__main__\":\n    driver(FIGURE)\n</code></pre> <p>Next, create a script <code>plan.py</code> as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import glob, script, static\nfrom stepup.reprep.api import convert_pdf_png, convert_svg_pdf\n\nfor path_svg in glob(\"*.svg\"):\n    convert_svg_pdf(path_svg)\nstatic(\"tile.py\")\nscript(\"tile.py\")\nconvert_pdf_png(\"figure.pdf\", resolution=150)\n</code></pre> <p>For this example to work, you also need to create four SVG figures of the same size: <code>triangle.svg</code>, <code>square.svg</code>, <code>pentagon.svg</code> and <code>hexagon.svg</code>.</p> <p>To run the example, make the scripts executable and run StepUp:</p> <pre><code>chmod +x plan.py tile.py\nstepup -n -w1\n</code></pre> <p>You should see the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n     PHASE \u2502 run\n  DIRECTOR \u2502 Launched worker 0\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 python -m stepup.reprep.convert_inkscape hexagon.svg hexagon.pdf\n   SUCCESS \u2502 python -m stepup.reprep.convert_inkscape hexagon.svg hexagon.pdf\n     START \u2502 inkscape hexagon.svg  --export-filename=hexagon.pdf --export-type=pdf\n   SUCCESS \u2502 inkscape hexagon.svg  --export-filename=hexagon.pdf --export-type=pdf\n     START \u2502 python -m stepup.reprep.convert_inkscape pentagon.svg pentagon.pdf\n   SUCCESS \u2502 python -m stepup.reprep.convert_inkscape pentagon.svg pentagon.pdf\n     START \u2502 inkscape pentagon.svg  --export-filename=pentagon.pdf --export-type=pdf\n   SUCCESS \u2502 inkscape pentagon.svg  --export-filename=pentagon.pdf --export-type=pdf\n     START \u2502 python -m stepup.reprep.convert_inkscape square.svg square.pdf\n   SUCCESS \u2502 python -m stepup.reprep.convert_inkscape square.svg square.pdf\n     START \u2502 inkscape square.svg  --export-filename=square.pdf --export-type=pdf\n   SUCCESS \u2502 inkscape square.svg  --export-filename=square.pdf --export-type=pdf\n     START \u2502 python -m stepup.reprep.convert_inkscape triangle.svg triangle.pdf\n   SUCCESS \u2502 python -m stepup.reprep.convert_inkscape triangle.svg triangle.pdf\n     START \u2502 inkscape triangle.svg  --export-filename=triangle.pdf --export-type=pdf\n   SUCCESS \u2502 inkscape triangle.svg  --export-filename=triangle.pdf --export-type=pdf\n     START \u2502 ./tile.py plan\n   SUCCESS \u2502 ./tile.py plan\n     START \u2502 ./tile.py run\n   SUCCESS \u2502 ./tile.py run\n     START \u2502 mutool draw -q -o figure.png -r 150 figure.pdf\n   SUCCESS \u2502 mutool draw -q -o figure.png -r 150 figure.pdf\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n     PHASE \u2502 watch\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>This is the PNG conversion of the resulting PDF figure:</p> <p></p>"},{"location":"advanced_topics/unplot/","title":"Unplot","text":""},{"location":"advanced_topics/unplot/#unplot","title":"Unplot","text":"<p>Version history</p> <p>This feature was added to StepUp RepRep 1.4.</p> <p>Unplot converts plots back into data points. (It is a sanitized version of Depix.)</p>"},{"location":"advanced_topics/unplot/#how-to-prepare-an-input-svg-file","title":"How to prepare an input SVG file","text":"<ol> <li> <p>If the plot is embedded in a PDF, use <code>pdfimages</code>    to extract the figures from the PDF as PBM files.    Most PDF viewers can easily extract bitmaps from a PDF:    right-click on the image and select \u201cSave Image As \u2026\u201d.</p> </li> <li> <p>Open the image containing the plot in Gimp,    crop it if necessary, and save it as a PNG or JPEG file.</p> </li> <li> <p>Open the PNG or JPG file in Inkscape.    Use the \u201clink\u201d option to avoid large SVG files in one of the following steps.</p> </li> <li> <p>Draw the x-axis and y-axis as two separate straight line segments,    i.e., lines with only one start node and one end node.    The accuracy of the extracted data will improve    if these line segments are made as long as possible.    It also helps to zoom in to place the nodes as accurately as possible.    You must make sure that the start and the end nodes are at well-defined points on the axes.    Unplot can handle cases where the x and y axes are not orthogonal or are rotated,    e.g. due to a bad scan.</p> </li> <li> <p>Draw one or more polylines consisting of straight line segments    over the curve(s) of interest.    Make sure that your drawing falls nicely over the curve in the scanned image,    as this will also determine the accuracy of the final data.    It may be helpful to use a brightly colored and semi-transparent line style.    Inkscape also supports node markers that make it easier to position the nodes,    as shown in the example below.    Zooming in on the data points also helps to optimize their position.</p> </li> <li> <p>Open the XML Editor in Inkscape. (Press <code>Ctrl-Shift-X</code>.)    Add attributes to the new paths you\u2019ve drawn needed to interpret them correctly:</p> <ul> <li>Select the x-axis in the figure and add the following attributes:<ul> <li><code>axis</code>: your name of the axis</li> <li><code>low</code>: numerical value corresponding to the start the path</li> <li><code>high</code>: numerical value corresponding to the end the path</li> <li><code>scal</code>: <code>linear</code> or <code>log</code></li> <li><code>unit</code>: the unit of the axis</li> </ul> </li> <li>Select the y-axis in the figure and add the same attributes for the second axis.</li> <li>The paths over the curves should be given a <code>data</code> attribute whose value is   is a label to identify the data series in the output.</li> </ul> </li> <li> <p>In the menu, select \u201cFile\u201d \u2794 \u201cSave As\u2026\u201d to save the file in SVG format.</p> </li> </ol>"},{"location":"advanced_topics/unplot/#example","title":"Example","text":"<p>Example source files: advanced_topics/unplot/</p> <p>The following plot has been taken from Wikipedia and the necessary paths have been drawn over it as input for Unplot. Open this file in Inkscape to inspect the paths in the XML Editor. You will find the following (among other attributes):</p> <pre><code>&lt;path\n    d=\"M 51.564216,441.96145 51.70753,13.139368\"\n    id=\"path2\"\n    low=\"0\"\n    unit=\"micron\"\n    high=\"450\"\n    scale=\"linear\"\n    axis=\"screw movement\" /&gt;\n&lt;path\n    d=\"m 51.564216,441.96145 415.207694,0.0146\"\n    id=\"path3\"\n    axis=\"mill speed\"\n    unit=\"mpm\"\n    low=\"0\"\n    high=\"1400\"\n    scale=\"linear\" /&gt;\n&lt;path\n    d=\"m 110.57991,284.1976 29.46788,-46.38471 30.43143,-32.0766 29.46052,-24.88177 29.73658,-20.27491 29.64224,-18.83789 29.69832,-17.71775 29.42497,-18.3225 29.57262,-14.312601 29.64572,-13.618158\"\n    id=\"path8\"\n    data=\"measured\" /&gt;\n</code></pre> <p>The <code>d</code> attribute encode the node positions of the paths and should not be changed in the XML editor. All other attributes were added manually in the XML editor by following the instructions above.</p> <p>As shown in the figure below, the start and intermediate nodes are marked with circles. The end node is a diamond. Hollow node markers can be easily aligned with data points in the original image.</p> <p></p> <p>To convert these paths into data, you can use the <code>unplot</code> function of StepUp RepRep as follows:</p> <pre><code>#!/usr/bin/env python3\nfrom stepup.core.api import static\nfrom stepup.reprep.api import unplot\n\nstatic(\"plot.svg\")\nunplot(\"plot.svg\")\n</code></pre> <p>To run the example, make the scripts executable and run StepUp:</p> <pre><code>chmod +x plan.py tile.py\nstepup -n -w1\n</code></pre> <p>You should see the following terminal output:</p> <pre><code>  DIRECTOR \u2502 Listening on /tmp/stepup-########/director\n  DIRECTOR \u2502 Launched worker 0\n     PHASE \u2502 run\n     START \u2502 ./plan.py\n   SUCCESS \u2502 ./plan.py\n     START \u2502 python -m stepup.reprep.unplot plot.svg plot.json\n   SUCCESS \u2502 python -m stepup.reprep.unplot plot.svg plot.json\n  WORKFLOW \u2502 Dumped to .stepup/workflow.mpk.xz\n  DIRECTOR \u2502 Stopping workers.\n  DIRECTOR \u2502 See you!\n</code></pre> <p>The output is a JSON file containing the extracted data points:</p> <pre><code>{\n  \"units\": {\n    \"screw movement\": \"micron\",\n    \"mill speed\": \"mpm\"\n  },\n  \"curves\": {\n    \"measured\": {\n      \"screw movement\": [\n        165.55739192319336,\n        214.23395596481842,\n        247.8958217249022,\n        274.007496016406,\n        295.2848049744838,\n        315.05412142861957,\n        333.64798044280985,\n        352.87644570256634,\n        367.89698355323765,\n        382.18878516864055\n      ],\n      \"mill speed\": [\n        198.81171861107973,\n        298.11943708971177,\n        400.69218307076636,\n        499.9993160884723,\n        600.2424613325304,\n        700.1691296912892,\n        800.2861512091725,\n        899.4808079569868,\n        999.1778305661308,\n        1099.1221147747872\n      ]\n    }\n  }\n}\n</code></pre> <p>Each curve is an item in the dictionary and the corresponding value is a list with two lists (x- and y-coordinates).</p>"},{"location":"advanced_topics/unplot/#tips-and-tricks","title":"Tips and tricks","text":"<p>Q. The data points are flipped horizontally or vertically. How can I fix this?</p> <p>A. You need to make sure that the order of the two points in the line segments for the x (or y) axes is compatible with the <code>low</code> and <code>high</code> attributes. Add a special end marker in Inkscape to identify the end point of the line segment. The menu item \u201cPath\u201d \u2794 \u201cReverse\u201d allows you to swap start and end.</p> <p>Q. How can I extract error bars from plots?</p> <p>A. Draw two polylines, one for each end of the error bar, and ensure they have the same number of nodes in the same order. When loading the JSON file created by unplot, you need to post-process the two paths. For example, for vertical error bars, average their x-coordinates and compute the difference of their y-coordinates.</p>"},{"location":"from_scratch/introduction/","title":"Introduction","text":"<p>This tutorial series has yet to be written.</p> <p>The goal is to show how to use StepUp RepRep without by starting from an empty Git repository, without relying on the template from the Template Tutorial.</p>"},{"location":"from_template/before_you_begin/","title":"Before You Begin","text":""},{"location":"from_template/before_you_begin/#initial-competences","title":"Initial Competences","text":"<p>The following competences are required (at a basic level) for this template to be useful.</p> <ul> <li>Unix</li> <li>LaTeX</li> <li>Git</li> <li>Python</li> </ul> <p>Without these competences, it is still possible to contribute to a publication created with StepUp RepRep, but it will be difficult to take the lead.</p>"},{"location":"from_template/before_you_begin/#required-software-and-configuration","title":"Required Software and Configuration","text":"<p>It is assumed that you have installed and configured the following software, ideally using your operating system\u2019s software installation tool (app store, package manager, pip, \u2026).</p> <ul> <li>Required:<ul> <li>Python &gt;= 3.11</li> <li>Git</li> <li>Git LFS</li> <li>The cookiecutter   (Only needed to initialize a new publication.)</li> </ul> </li> <li>Recommended:<ul> <li>Inkscape &gt;= 1.2   (Only needed when the source contains SVG files.   It must be executable as <code>inkscape</code> on the command-line.)</li> <li><code>mutool</code> from MuPDF</li> <li>TexLive &gt;= 2022</li> <li>direnv</li> <li>A Text editor compatible with editorconfig</li> </ul> </li> </ul> <p>Installation instructions for \u2026</p>"},{"location":"from_template/before_you_begin/#ubuntu","title":"Ubuntu","text":"<p>On Ubuntu 22, the required and recommended software can be installed using the following steps:</p> <ol> <li> <p>Install the following packages:</p> <pre><code>sudo apt install \\\n  python3.11 \\\n  python3.11-venv \\\n  python3-pip \\\n  python3-cookiecutter \\\n  inkscape \\\n  texlive-full \\\n  git \\\n  git-lfs \\\n  direnv \\\n  mupdf-tools \\\n  libreoffice\n</code></pre> </li> <li> <p>Fira fonts (used for presentations) must be installed manually,    because they have not been packaged for Ubuntu yet.    This can be achieved as follows:</p> <pre><code>mkdir -p ~/.local/share/fonts\ncd ~/.local/share/fonts\nwget 'https://github.com/firamath/firamath/releases/download/v0.3.4/firamath.tds.zip'\nunzip -j firamath.tds.zip fonts/opentype/public/firamath/FiraMath-Regular.otf\nrm firamath.tds.zip\ncd\n</code></pre> <pre><code>mkdir -p ~/.local/share/fonts\ncd ~/.local/share/fonts\nwget 'https://github.com/mozilla/Fira/archive/refs/tags/4.202.zip'\nunzip -j 4.202.zip Fira-4.202/otf/*.otf\nchmod -x *.otf\nrm 4.202.zip\ncd\n</code></pre> </li> </ol>"},{"location":"from_template/before_you_begin/#fedora","title":"Fedora","text":"<p>On Fedora (&gt;= 38), the required and recommended software can be installed using the following command:</p> <pre><code>sudo dnf install \\\n  python \\\n  python3-pip \\\n  python3-virtualenv \\\n  python3-cookiecutter \\\n  inkscape \\\n  texlive-scheme-full \\\n  git \\\n  git-lfs \\\n  direnv \\\n  mupdf \\\n  libreoffice \\\n  mozilla-fira* \\\n  texlive-fira*\n</code></pre>"},{"location":"from_template/before_you_begin/#conda-or-pip","title":"Conda or Pip","text":"<p>A new dedicated pip or micromamba software environment is created for each publication. It is up to each co-author to decide which one they prefer:</p> <ol> <li>A virtual environment with pip can install the dependencies    with low time, bandwidth and storage overheads.    A sufficiently recent Python version must already be installed.</li> <li>A micromamba environment (the fastest and lightest way to use conda)    is a bit more powerful than pip.    In principle, you can use it on a system without (a recent version of) Python.    It can also install non-Python dependencies.    The main drawbacks are the time it takes to install, the bandwidth consumed during installation,    and the amount of disk space used.    Because the cookiecutter requires Python &gt;= 3.7, you already need a working Python version    before installing micromamba.</li> </ol> <p>The aim is to isolate this software environment from your operating system as much as possible. This may be hampered by your local configuration, for example:</p> <ul> <li> <p>Another always-on pip environment (activated in your shell profile, like <code>.bashrc</code>)   may not work well when pip is used for the publication.</p> </li> <li> <p>Similarly, another always-on conda environment (activated in your shell profile)   may not work well when micromamba is used for the publication.</p> </li> <li> <p>Using pip for the publication on top of your default conda can work well.   (Needs more testing.)</p> </li> </ul>"},{"location":"from_template/create_or_clone_a_project/","title":"Create or Clone a Project","text":"<p>Follow route 1a + 2 OR route 1b + 2.</p>"},{"location":"from_template/create_or_clone_a_project/#0-first-time-git-users","title":"0) First-time Git Users","text":"<p>If you have not used Git before, you probably haven\u2019t configured it yet. At least run the following (with correct name and email):</p> <pre><code>git config --global init.defaultBranch main\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"Your.Name@email.com\"\ngit config --global core.editor nano\n</code></pre> <p>Also, go through a Git Tutorial to become familiar with the basic concepts.</p>"},{"location":"from_template/create_or_clone_a_project/#1a-start-a-new-publication","title":"1a) Start a New Publication","text":"<ul> <li> <p>Start a new publication using the cookiecutter:</p> <pre><code>cookiecutter https://github.com/reproducible-reporting/templates\n</code></pre> <p>Follow the instructions on the terminal. You will need to enter:</p> <ul> <li><code>slug</code>:   This is a short name for the directory containing all sources and compiled outputs.   Use only lower-case characters, digits and hyphens.</li> <li><code>article</code>:   The LaTeX article template you want to use.</li> <li><code>supp</code>:   The LaTeX supporting of supplementary information template you want to use.</li> <li><code>cover</code>:   The LaTeX template for the cover letter.</li> </ul> </li> <li> <p>Enter the newly created directory (<code>slug</code>) and initialize the Git repository</p> <pre><code>cd 'slug'\ngit init\n</code></pre> <p>Replace <code>'slug'</code> with the directory created by the cookiecutter.</p> </li> <li> <p>Before making a first commit, define the software requirements,   e.g., for post-processing and plotting, in <code>requirements.in</code> and/or <code>environment.yaml</code>.   Pin versions of your dependencies with <code>==X.Y.Z</code> as shown in the example files in the template.</p> <ul> <li>If you must use micromamba, because you have non-Python dependencies,   you can remove <code>requirements.in</code>  and <code>setup-venv-pip.sh</code>.</li> <li>If you prefer to create a pure Python project,   you can remove <code>environment.yaml</code> and <code>setup-venv-micromamba.sh</code>.</li> </ul> <p>Note that the Python environment uses pip-tools to manage dependencies. This facilitates reproducibility because the results of the package dependency calculation are stored in <code>requirements.txt</code> and this file is also committed to the Git repository</p> </li> <li> <p>Now you can add all the files, commit them, define a remote URL and push the initial contents online:</p> <pre><code>git add .\ngit commit -a -m \"Initial commit\"\ngit remote add origin 'remote url'\ngit push origin main -u\n</code></pre> <p>Replace <code>'remote url'</code> with the correct one. This depends on which online service is used to share the Git repository with your co-authors. If in doubt, create a private repository on GitHub.</p> </li> </ul>"},{"location":"from_template/create_or_clone_a_project/#1b-clone-an-existing-publication","title":"1b) Clone an Existing Publication","text":"<p>You need a <code>'remote url'</code> of an existing publication, which one of your co-authors created. Substitute this <code>'remote url'</code> in the following command, which should be executed in the terminal:</p> <pre><code>git clone 'remote url'\ncd 'slug'\n</code></pre> <p>Replace <code>'slug'</code> with the directory created by <code>git clone</code>.</p>"},{"location":"from_template/create_or_clone_a_project/#2-set-up-the-software-environment","title":"2) Set Up the Software Environment","text":"<p>(It is assumed that your current working directory is the <code>'slug'</code> defined in the previous section 1a or 1b.)</p> <ul> <li> <p>Install the software environment, using ONE of the following commands (NOT more than one):</p> <ul> <li> <p>Fedora or Ubuntu 24:</p> <pre><code>./setup-venv-pip.sh\n</code></pre> </li> <li> <p>Ubuntu 22</p> <pre><code>PYTHON3=python3.11 ./setup-venv-pip.sh\n</code></pre> </li> <li> <p>Any OS but requires more resources</p> <pre><code>./setup-venv-micromamba.sh\n</code></pre> </li> </ul> </li> <li> <p>Activate your software environment:</p> <pre><code>source .envrc\n</code></pre> <p>This activation is required each time you open a new terminal. It is not recommended to add publication-specific activation scripts to your <code>~/.bashrc</code>. If you find it too tedious to run the activation script over and over again, try using <code>direnv</code>. Once <code>direnv</code> is installed and configured in your shell profile, you only need to allow it once with <code>direnv allow .</code>, and the <code>.envrc</code> script is automatically sourced when you change to the directory of the Git repository.</p> </li> <li> <p>Install <code>pre-commit</code> and <code>git-lfs</code> into the new repository:</p> <pre><code>pre-commit install\ngit-lfs install\n</code></pre> <p>This is needed each time you create or clone a Git repository. Normally, that is only once per publication.</p> </li> <li> <p>You should now be able to build the template manuscript and related documents   with StepUp RepRep as follows:</p> <pre><code>cd latest-draft\nstepup -n\n</code></pre> </li> </ul>"},{"location":"from_template/introduction/","title":"Introduction","text":"<p>This Template Tutorial is the quickest way to get started with StepUp RepRep. It shows you how to start a new project from our templates repository. The template contains a pre-configured StepUp workflow that includes:</p> <ul> <li>A dataset directory for externally acquired data, used as input for your workflow.</li> <li>A results directory for collecting scripts that derive   results, tables and figures from the dataset,   which can then be included in the LaTeX documents below.</li> <li>Several LaTeX documents (from which you can remove the ones you don\u2019t need):   article, supporting information, cover letter, reply letter, and presentation.</li> <li>An upload directory. Once the workflow has been executed,   it will contain the files for uploading to   a publisher, preprint server, conference website, etc.</li> <li>Configuration files for the tools used in the above steps.</li> </ul> <p>All these components interact with each other. For example, if you change a script that analyses some data, subsequent steps that use the analysis as input will be updated when you run the workflow again. This will not only update the figures and tables in your paper. The ZIP file for the publisher will also be updated accordingly.</p>"},{"location":"from_template/working_on_a_project/","title":"Working on a Project","text":""},{"location":"from_template/working_on_a_project/#the-stepup-program-and-planpy","title":"The <code>stepup</code> Program and <code>plan.py</code>","text":"<p>We strongly recommend that you follow the StepUp Core \u201cGetting Started\u201d tutorials, to familiarize yourself with the <code>stepup</code> program. This is the build tool that orchestrates the processing of results and the compilation of the paper. These tutorials will give you a good understanding of how StepUp works and how to use it.</p> <p>Now that you have gained a basic understanding of StepUp Core, it will become clear why a <code>plan.py</code> file is included in the template. The off-the-shelf <code>plan.py</code> already covers quite a few use cases, but consider it a good starting point for further development. In addition to the functions in <code>stepup.core.api</code>, StepUp RepRep provides more functionality geared towards scientific publishing. Reference documentation for these functions can be found here:</p> <ul> <li><code>stepup.reprep.api</code></li> <li><code>stepup.reprep.tile_pdf</code></li> </ul>"},{"location":"from_template/working_on_a_project/#git","title":"Git","text":"<p>Aside from making small changes, working on a StepUp project can greatly benefit from basic Git skills. If you are new to Git, start with small steps and take on bigger challenges as you gain experience.</p>"},{"location":"from_template/working_on_a_project/#recommended-git-tutorials","title":"Recommended Git Tutorials","text":"<p>The following sections of GitHub\u2019s guide to Git are most relevant:</p> <ul> <li>Understanding the GitHub flow</li> <li>Hello World</li> <li>Git Handbook</li> <li>Forking projects</li> </ul> <p>More recommended visual Git resources include:</p> <ul> <li>A Visual Git Reference</li> <li>5 Git resources for visual learners</li> <li>Learn Git Branching (an online game to learn Git)</li> </ul>"},{"location":"from_template/working_on_a_project/#keep-clean","title":"Keep Clean","text":"<p>It is essential to keep the Git repository organized and understandable by your co-authors. When in doubt, ask one of your co-authors to review before making a commit.</p> <p>The project template uses  <code>pre-commit</code> to clean up trivial annoyances. Ensure you have installed <code>pre-commit</code> and activated it on your clone of the repository.</p> <p>To remove all stale files (defined in <code>.gitignore</code>), run <code>git clean -dfX</code>. However, do not use this command until you have committed all important files, as it may inadvertently remove work in progress.</p>"},{"location":"from_template/working_on_a_project/#managing-software","title":"Managing software","text":"<p>It is recommended to pin the versions of software dependencies, so everyone is working with a consistent software environment.</p> <p>This can be done by specifying versions in the <code>requirements.in</code> or <code>environment.yaml</code> files, e.g.</p> <pre><code>scipy==1.13.1\n</code></pre> <p>instead of just</p> <pre><code>scipy\n</code></pre> <p>For pip-based installations, the template uses pip-tools to derive a <code>requirements.txt</code> from <code>requirements.in</code>. This will pin not only the versions of your direct dependencies, but also dependencies of dependencies, etc.</p> <p>If one or more dependencies need to be updated, change their versions in <code>requirements.txt</code> and execute:</p> <pre><code>pip-compile --generate-hashes requirements.in\npip-sync\n</code></pre> <p>If someone else has changed the <code>requirements.in</code> and updated the <code>requirements.txt</code> with <code>pip-compile</code>, you only need to run <code>pip-sync</code> to update your local environment.</p>"},{"location":"reference/stepup.reprep.api/","title":"stepup.reprep.api","text":"<p>Application programming interface for StepUp RepRep.</p>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.add_notes_pdf","title":"<code>add_notes_pdf(path_src, path_notes, path_dst, optional=False, block=False)</code>","text":"<p>Add a notes page at every even page of a PDF file.</p> <p>Parameters:</p> <ul> <li> <code>path_src</code>               (<code>str</code>)           \u2013            <p>The original PDF document without notes pages.</p> </li> <li> <code>path_notes</code>               (<code>str</code>)           \u2013            <p>A single-page PDF document with a page suitable for taking notes.</p> </li> <li> <code>path_dst</code>               (<code>str</code>)           \u2013            <p>The output PDF with notes pages inserted.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def add_notes_pdf(\n    path_src: str, path_notes: str, path_dst: str, optional: bool = False, block: bool = False\n) -&gt; StepInfo:\n    \"\"\"Add a notes page at every even page of a PDF file.\n\n    Parameters\n    ----------\n    path_src\n        The original PDF document without notes pages.\n    path_notes\n        A single-page PDF document with a page suitable for taking notes.\n    path_dst\n        The output PDF with notes pages inserted.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    return step(\n        \"add-notes-pdf ${inp} ${out}\",\n        inp=[path_src, path_notes],\n        out=path_dst,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.cat_pdf","title":"<code>cat_pdf(paths_inp, path_out, *, insert_blank=False, optional=False, block=False)</code>","text":"<p>Concatenate the pages of multiple PDFs into one document</p> <p>Parameters:</p> <ul> <li> <code>paths_inp</code>               (<code>Collection[str]</code>)           \u2013            <p>The input PDF files.</p> </li> <li> <code>path_out</code>               (<code>str</code>)           \u2013            <p>The concatenated PDF.</p> </li> <li> <code>insert_blank</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Insert a blank page after a PDF with an odd number of pages. The last page of each PDF is used to determine the size of the added blank page.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def cat_pdf(\n    paths_inp: Collection[str],\n    path_out: str,\n    *,\n    insert_blank: bool = False,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Concatenate the pages of multiple PDFs into one document\n\n    Parameters\n    ----------\n    paths_inp\n        The input PDF files.\n    path_out\n        The concatenated PDF.\n    insert_blank\n        Insert a blank page after a PDF with an odd number of pages.\n        The last page of each PDF is used to determine the size of the added blank page.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    args = [\"cat-pdf\", \"${inp}\", \"${out}\"]\n    if insert_blank:\n        args.append(\"--insert-blank\")\n    return step(\n        \" \".join(args),\n        inp=paths_inp,\n        out=path_out,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.check_hrefs","title":"<code>check_hrefs(path_src, path_config=None, block=False)</code>","text":"<p>Check hyper references in a Markdown, HTML or PDF file.</p> <p>Parameters:</p> <ul> <li> <code>path_src</code>               (<code>str</code>)           \u2013            <p>The source Markdown, HTML or PDF to check.</p> </li> <li> <code>path_config</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The configuration file. Defaults to <code>${REPREP_CHECK_HREFS_CONFIG}</code> variable or <code>check_hrefs.yaml</code> if it is not set.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def check_hrefs(path_src: str, path_config: str | None = None, block: bool = False) -&gt; StepInfo:\n    \"\"\"Check hyper references in a Markdown, HTML or PDF file.\n\n    Parameters\n    ----------\n    path_src\n        The source Markdown, HTML or PDF to check.\n    path_config\n        The configuration file.\n        Defaults to `${REPREP_CHECK_HREFS_CONFIG}` variable or `check_hrefs.yaml` if it is not set.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_src = subs(path_src)\n        path_config = subs(path_config)\n    args = [\"check_hrefs\", shlex.quote(path_src)]\n    inp_paths = [path_src]\n    if path_config is not None:\n        inp_paths.append(path_config)\n        args.extend([\"-c\", path_config])\n    return step(\" \".join(args), inp=inp_paths, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.compile_latex","title":"<code>compile_latex(path_tex, *, run_bibtex=True, maxrep=5, workdir='./', latex=None, bibtex=None, inventory=None, optional=False, block=False)</code>","text":"<p>Create a step for the compilation of a LaTeX source.</p> <p>Parameters:</p> <ul> <li> <code>path_tex</code>               (<code>str</code>)           \u2013            <p>The main tex source file. This argument may contain environment variables.</p> </li> <li> <code>run_bibtex</code>           \u2013            <p>By default, when bib files are used, BibTeX is invoked. This can be overruled by setting this argument to False, which is useful when recompiling sources with fixed bbl files.</p> </li> <li> <code>maxrep</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The maximum number of repetitions of the LaTeX command in case the aux file keeps changing.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>The working directory where the LaTeX command must be executed.</p> </li> <li> <code>latex</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the LaTeX executable. Note that only PDF-producing LaTeX compilers are supported: <code>pdflatex</code>, <code>xelatex</code> or <code>lualatex</code>. Defaults to <code>${REPREP_LATEX}</code> variable or <code>pdflatex</code> if the variable is unset.</p> </li> <li> <code>bibtex</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the BibTeX executable. Defaults to <code>${REPREP_BIBTEX}</code> variable or <code>bibtex</code> if the variable is unset.</p> </li> <li> <code>inventory</code>               (<code>str | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If set to a <code>str</code>, it specifies the inventory file to write. If set to  <code>True</code>, the inventory file is written to the default location, which is the stem of the source file with <code>-inventory.txt</code> appended. When the environment variable <code>REPREP_LATEX_INVENTORY</code> is set to <code>1</code>, the inventory file is always written, unless this argument is set to <code>False</code>.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <p>The LaTeX source is compiled with the <code>rr-compile-latex</code> command, which can detect dependencies on other files by scanning for <code>\\input</code>, <code>\\include</code>, <code>\\includegraphics</code>, etc. Due to the complexity of LaTeX, the dependency scanning is not perfect. You can manually specify dependencies in the LaTeX source with <code>%REPREP input inp_path</code>. When <code>inp_path</code> is a relative path, it is interpreted in the same way as the LaTeX compiler would resolve it. You can also hide lines from the dependency scanner by adding <code>%REPREP ignore</code>.</p> Source code in <code>stepup/reprep/api.py</code> <pre><code>def compile_latex(\n    path_tex: str,\n    *,\n    run_bibtex=True,\n    maxrep: int = 5,\n    workdir: str = \"./\",\n    latex: str | None = None,\n    bibtex: str | None = None,\n    inventory: str | bool | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Create a step for the compilation of a LaTeX source.\n\n    Parameters\n    ----------\n    path_tex\n        The main tex source file.\n        This argument may contain environment variables.\n    run_bibtex\n        By default, when bib files are used, BibTeX is invoked.\n        This can be overruled by setting this argument to False,\n        which is useful when recompiling sources with fixed bbl files.\n    maxrep\n        The maximum number of repetitions of the LaTeX command\n        in case the aux file keeps changing.\n    workdir\n        The working directory where the LaTeX command must be executed.\n    latex\n        Path to the LaTeX executable. Note that only PDF-producing LaTeX compilers are supported:\n        `pdflatex`, `xelatex` or `lualatex`.\n        Defaults to `${REPREP_LATEX}` variable or `pdflatex` if the variable is unset.\n    bibtex\n        Path to the BibTeX executable.\n        Defaults to `${REPREP_BIBTEX}` variable or `bibtex` if the variable is unset.\n    inventory\n        If set to a `str`, it specifies the inventory file to write.\n        If set to  `True`, the inventory file is written to the default location,\n        which is the stem of the source file with `-inventory.txt` appended.\n        When the environment variable `REPREP_LATEX_INVENTORY` is set to `1`,\n        the inventory file is always written, unless this argument is set to `False`.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    The LaTeX source is compiled with the `rr-compile-latex` command,\n    which can detect dependencies on other files by scanning for\n    `\\\\input`, `\\\\include`, `\\\\includegraphics`, etc.\n    Due to the complexity of LaTeX, the dependency scanning is not perfect.\n    You can manually specify dependencies in the LaTeX source with `%REPREP input inp_path`.\n    When `inp_path` is a relative path,\n    it is interpreted in the same way as the LaTeX compiler would resolve it.\n    You can also hide lines from the dependency scanner by adding `%REPREP ignore`.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_tex = subs(path_tex)\n    if not path_tex.endswith(\".tex\"):\n        raise ValueError(f\"The input of the latex command must end with .tex, got {path_tex}.\")\n\n    prefix = path_tex[:-4]\n    path_pdf = f\"{prefix}.pdf\"\n\n    args = [\"compile-latex\", shlex.quote(path_tex)]\n    inp_paths = [path_tex]\n    out_paths = [path_pdf, f\"{prefix}.aux\", f\"{prefix}.fls\"]\n    if maxrep != 5:\n        args.append(\"--maxrep=\" + shlex.quote(str(maxrep)))\n    if latex is not None:\n        args.append(\"--latex=\" + shlex.quote(latex))\n    if run_bibtex:\n        args.append(\"--run-bibtex\")\n        if bibtex is not None:\n            args.append(\"--bibtex=\" + shlex.quote(bibtex))\n    if inventory is None:\n        inventory = string_to_bool(getenv(\"REPREP_LATEX_INVENTORY\", \"0\"))\n    if inventory is True:\n        inventory = f\"{prefix}-inventory.txt\"\n    if isinstance(inventory, str):\n        args.append(\"--inventory=\" + shlex.quote(inventory))\n        out_paths.append(inventory)\n    return step(\n        \" \".join(args),\n        inp=inp_paths,\n        out=out_paths,\n        workdir=workdir,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.compile_typst","title":"<code>compile_typst(path_typ, dest=None, *, sysinp=None, resolution=None, workdir='./', typst=None, keep_deps=False, typst_args=(), inventory=None, optional=False, block=False)</code>","text":"<p>Create a step for the compilation of a Typst source.</p> <p>Warning</p> <p>This feature will only work well with typst 0.13 or later.</p> <p>Support for typst in StepUp RepRep is experimental. Expect breaking changes in future releases. Some limitations include:</p> <ul> <li>SVG figures with references to external bitmaps are not processed correctly.   These bitmaps are not rendered, neither are they included in the dep file.   For this problem, a workaround was suggested here:   https://github.com/typst/typst/issues/5335</li> <li>When the typst compiler detects an error in the input, it doesn\u2019t write the dep file.   This means that StepUp cannot reschedule it, even if that would fix the problem.   If it would know which files are used, it would see which ones are outdated,   rebuild them and then retry the typst command.   For more details, see:   https://github.com/typst/typst/issues/5886</li> </ul> <p>Parameters:</p> <ul> <li> <code>path_typ</code>               (<code>str</code>)           \u2013            <p>The main typst source file. This argument may contain environment variables.</p> </li> <li> <code>dest</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output destination: <code>None</code>, a directory or a file. For SVG and PNG outputs, this argument must be specified with the desired extension. If the output contains any of <code>{p}</code>, <code>{0p}</code> or <code>{t}</code>, the output paths are not known a priori and will be amended.</p> </li> <li> <code>sysinp</code>               (<code>dict[str, str | Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary with the input arguments passed to <code>typst</code>with <code>--input key=val</code>. Keys and values are converted to strings. When values are <code>Path</code> instances, they are treated as input dependencies for the step. These parameters are available in the document as <code>#sys.inputs.key</code>.</p> </li> <li> <code>resolution</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the bitmap in dots per inch (dpi), only relevant for PNG output.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>The working directory where the LaTeX command must be executed.</p> </li> <li> <code>typst</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the Typst executable. Defaults to <code>${REPREP_TYPST}</code> variable or <code>typst</code> if the variable is unset.</p> </li> <li> <code>keep_deps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the dependency file is kept after the compilation. The dependency file is also kept if the environment variable <code>REPREP_KEEP_TYPST_DEPS</code> is set to <code>\"1\"</code>.</p> </li> <li> <code>typst_args</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Additional arguments for typst. The defaults is <code>${REPREP_TYPST_ARGS}</code>, if the environment variable is defined.</p> </li> <li> <code>inventory</code>               (<code>str | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If set to a <code>str</code>, it specifies the inventory file to write. If set to  <code>True</code>, the inventory file is written to the default location, which is the stem of the source file with <code>-inventory.txt</code> appended. When the environment variable <code>REPREP_TYPST_INVENTORY</code> is set to <code>1</code>, the inventory file is always written, unless this argument is set to <code>False</code>.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def compile_typst(\n    path_typ: str,\n    dest: str | None = None,\n    *,\n    sysinp: dict[str, str | Path] | None = None,\n    resolution: int | None = None,\n    workdir: str = \"./\",\n    typst: str | None = None,\n    keep_deps: bool = False,\n    typst_args: Collection[str] = (),\n    inventory: str | bool | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Create a step for the compilation of a Typst source.\n\n    !!! warning\n\n        This feature will only work well with typst 0.13 or later.\n\n        Support for typst in StepUp RepRep is experimental.\n        Expect breaking changes in future releases.\n        Some limitations include:\n\n        - SVG figures with references to external bitmaps are not processed correctly.\n          These bitmaps are not rendered, neither are they included in the dep file.\n          For this problem, a workaround was suggested here:\n          https://github.com/typst/typst/issues/5335\n        - When the typst compiler detects an error in the input, it doesn't write the dep file.\n          This means that StepUp cannot reschedule it, even if that would fix the problem.\n          If it would know which files are used, it would see which ones are outdated,\n          rebuild them and then retry the typst command.\n          For more details, see:\n          https://github.com/typst/typst/issues/5886\n\n    Parameters\n    ----------\n    path_typ\n        The main typst source file.\n        This argument may contain environment variables.\n    dest\n        Output destination: `None`, a directory or a file.\n        For SVG and PNG outputs, this argument must be specified with the desired extension.\n        If the output contains any of `{p}`, `{0p}` or `{t}`, the output paths are not\n        known a priori and will be amended.\n    sysinp\n        A dictionary with the input arguments passed to `typst`with `--input key=val`.\n        Keys and values are converted to strings.\n        When values are `Path` instances, they are treated as input dependencies for the step.\n        These parameters are available in the document as `#sys.inputs.key`.\n    resolution\n        The resolution of the bitmap in dots per inch (dpi),\n        only relevant for PNG output.\n    workdir\n        The working directory where the LaTeX command must be executed.\n    typst\n        Path to the Typst executable.\n        Defaults to `${REPREP_TYPST}` variable or `typst` if the variable is unset.\n    keep_deps\n        If `True`, the dependency file is kept after the compilation.\n        The dependency file is also kept if the environment variable\n        `REPREP_KEEP_TYPST_DEPS` is set to `\"1\"`.\n    typst_args\n        Additional arguments for typst.\n        The defaults is `${REPREP_TYPST_ARGS}`, if the environment variable is defined.\n    inventory\n        If set to a `str`, it specifies the inventory file to write.\n        If set to  `True`, the inventory file is written to the default location,\n        which is the stem of the source file with `-inventory.txt` appended.\n        When the environment variable `REPREP_TYPST_INVENTORY` is set to `1`,\n        the inventory file is always written, unless this argument is set to `False`.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_typ = subs(path_typ)\n        dest = subs(dest)\n    if not path_typ.endswith(\".typ\"):\n        raise ValueError(f\"The input of the typst command must end with .typ, got {path_typ}.\")\n    path_out = make_path_out(path_typ, dest, \".pdf\", [\".svg\", \".png\"])\n\n    stem = path_typ[:-4]\n    args = [\"compile-typst\"]\n    if resolution is not None:\n        args.append(f\"--resolution={shlex.quote(str(resolution))}\")\n    if typst is not None:\n        args.append(f\"--typst={shlex.quote(typst)}\")\n    paths_out = []\n    if not any(x in path_out for x in (\"{p}\", \"{0p}\", \"{t}\")):\n        paths_out.append(path_out)\n    if keep_deps or string_to_bool(getenv(\"REPREP_KEEP_TYPST_DEPS\", \"0\")):\n        args.append(\"--keep-deps\")\n        paths_out.append(f\"{stem}.dep\")\n    if inventory is None:\n        inventory = string_to_bool(getenv(\"REPREP_TYPST_INVENTORY\", \"0\"))\n    if inventory is True:\n        inventory = f\"{stem}-inventory.txt\"\n    if isinstance(inventory, str):\n        args.append(f\"--inventory={shlex.quote(inventory)}\")\n        paths_out.append(inventory)\n    args.append(shlex.quote(path_typ))\n    if path_typ[:-4] != path_out[:-4]:\n        args.append(\"--out=\" + shlex.quote(path_out))\n    path_inp = [path_typ]\n    if sysinp is not None and len(sysinp) &gt; 0:\n        args.append(\"--sysinp\")\n        for key, val in sysinp.items():\n            args.append(shlex.quote(str(key)) + \"=\" + shlex.quote(str(val)))\n            if isinstance(val, Path):\n                path_inp.append(val)\n    if len(typst_args) &gt; 0:\n        args.append(\"--\")\n        args.extend(shlex.quote(typst_arg) for typst_arg in typst_args)\n\n    return step(\n        \" \".join(args),\n        inp=path_inp,\n        out=paths_out,\n        workdir=workdir,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_inkscape","title":"<code>convert_inkscape(path_svg, path_out, *, inkscape=None, inkscape_args=(), optional=False, block=False)</code>","text":"<p>Convert an SVG figure to a PDF file, detecting dependencies of the SVG on other files.</p> <p>Parameters:</p> <ul> <li> <code>path_svg</code>               (<code>str</code>)           \u2013            <p>The input SVG figure. It may contain  tags referring to other files included in the figure.</p> </li> <li> <code>path_out</code>               (<code>str</code>)           \u2013            <p>The output PDF or PNG file. Other formats are not supported.</p> </li> <li> <code>inkscape</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the inkscape executable. Defaults to <code>${REPREP_INKSCAPE}</code> variable or <code>inkscape</code> if the variable is unset.</p> </li> <li> <code>inkscape_args</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Additional arguments to pass to inkscape. E.g. <code>[\"-T\"]</code> to convert text to glyphs in PDFs. Depending on the extension of the output, the default is <code>${REPREP_INKSCAPE_PDF_ARGS}</code> or <code>${REPREP_INKSCAPE_PNG_ARGS}</code>, if the environment variable is defined.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <p>A wrapper around inkscape is used to carry out the conversion: <code>stepup.reprep.convert_inkscape</code>. The wrapper scans the SVG for dependencies, which may be a bit slow in case of large files.</p> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_inkscape(\n    path_svg: str,\n    path_out: str,\n    *,\n    inkscape: str | None = None,\n    inkscape_args: Collection[str] = (),\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Convert an SVG figure to a PDF file, detecting dependencies of the SVG on other files.\n\n    Parameters\n    ----------\n    path_svg\n        The input SVG figure.\n        It may contain &lt;img&gt; tags referring to other files included in the figure.\n    path_out\n        The output PDF or PNG file. Other formats are not supported.\n    inkscape\n        The path to the inkscape executable.\n        Defaults to `${REPREP_INKSCAPE}` variable or `inkscape` if the variable is unset.\n    inkscape_args\n        Additional arguments to pass to inkscape. E.g. `[\"-T\"]` to convert text to glyphs in PDFs.\n        Depending on the extension of the output, the default is `${REPREP_INKSCAPE_PDF_ARGS}` or\n        `${REPREP_INKSCAPE_PNG_ARGS}`, if the environment variable is defined.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    A wrapper around inkscape is used to carry out the conversion: `stepup.reprep.convert_inkscape`.\n    The wrapper scans the SVG for dependencies, which may be a bit slow in case of large files.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_svg = subs(path_svg)\n        path_out = subs(path_out)\n    if not path_svg.endswith(\".svg\"):\n        raise ValueError(\"The SVG file must have extension .svg\")\n    if not path_out.endswith((\".pdf\", \".png\")):\n        raise ValueError(\"The output file must have extension .pdf or .png\")\n    args = [\"convert-inkscape\", shlex.quote(path_svg), shlex.quote(path_out)]\n    if inkscape is not None:\n        args.append(\"--inkscape=\" + shlex.quote(inkscape))\n    if len(inkscape_args) &gt; 0:\n        args.append(\"--\")\n        args.extend(shlex.quote(inkscape_arg) for inkscape_arg in inkscape_args)\n    return step(\" \".join(args), inp=path_svg, out=path_out, block=block, optional=optional)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_inkscape_pdf","title":"<code>convert_inkscape_pdf(path_svg, dest=None, *, inkscape=None, inkscape_args=(), optional=False, block=False)</code>","text":"<p>Shorthand for <code>convert_inkscape</code> with the output file derived from the SVG file.</p> <p>The <code>dest</code> argument can be <code>None</code>, a directory or a file.</p> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_inkscape_pdf(\n    path_svg: str,\n    dest: str | None = None,\n    *,\n    inkscape: str | None = None,\n    inkscape_args: Collection[str] = (),\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Shorthand for `convert_inkscape` with the output file derived from the SVG file.\n\n    The `dest` argument can be `None`, a directory or a file.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_svg = subs(path_svg)\n        dest = subs(dest)\n    if not path_svg.endswith(\".svg\"):\n        raise ValueError(\"The SVG file must have extension .svg\")\n    path_pdf = make_path_out(path_svg, dest, \".pdf\")\n    return convert_inkscape(\n        path_svg,\n        path_pdf,\n        inkscape=inkscape,\n        inkscape_args=inkscape_args,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_inkscape_png","title":"<code>convert_inkscape_png(path_svg, dest=None, *, inkscape=None, inkscape_args=(), optional=False, block=False)</code>","text":"<p>Shorthand for <code>convert_inkscape</code> with the output file derived from the SVG file.</p> <p>The <code>dest</code> argument can be <code>None</code>, a directory or a file. See <code>make_path_out</code>.</p> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_inkscape_png(\n    path_svg: str,\n    dest: str | None = None,\n    *,\n    inkscape: str | None = None,\n    inkscape_args: Collection[str] = (),\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Shorthand for `convert_inkscape` with the output file derived from the SVG file.\n\n    The `dest` argument can be `None`, a directory or a file. See `make_path_out`.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_svg = subs(path_svg)\n        dest = subs(dest)\n    if not path_svg.endswith(\".svg\"):\n        raise ValueError(\"The SVG file must have extension .svg\")\n    path_png = make_path_out(path_svg, dest, \".png\")\n    return convert_inkscape(\n        path_svg,\n        path_png,\n        inkscape=inkscape,\n        inkscape_args=inkscape_args,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_jupyter","title":"<code>convert_jupyter(path_nb, dest=None, *, inp=(), out=(), execute=True, to=None, nbargs=None, jupyter=None, optional=False, pool=None, block=False)</code>","text":"<p>Convert a Jupyter notebook, by default to HTML with execution of cells.</p> <p>Warning</p> <p>Support for <code>juptyer nbconvert</code> in StepUp RepRep is experimental. Expect breaking changes in future releases.</p> <p>Parameters:</p> <ul> <li> <code>path_nb</code>               (<code>str</code>)           \u2013            <p>The input Jupyter notebook.</p> </li> <li> <code>dest</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output destination: <code>None</code>, a directory or a file.</p> </li> <li> <code>inp</code>               (<code>str | Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more input files used by the notebook. You can also declare inputs with <code>amend(inp=...)</code> in the notebook, but specifying them here will make the scheduling more efficient.</p> </li> <li> <code>out</code>               (<code>str | Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more output files produced by the notebook. You can also declare outputs with <code>amend(out=...)</code> in the notebook, but you can specify them here if you want to make the notebook execution optional, i.e. dependent on whether the outputs are used in other steps.</p> </li> <li> <code>execute</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, the notebook is executed before conversion.</p> </li> <li> <code>to</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format. The default depends on the extension of the output file. if <code>to</code> is given and <code>dest</code> is <code>None</code> or a directory, the <code>to</code> argument is used to determine the output file extension.</p> </li> <li> <code>nbargs</code>               (<code>str | dict | list | None</code>, default:                   <code>None</code> )           \u2013            <p>If <code>str</code>, it is passed literally as additional argument to the notebook through the environment variable <code>REPREP_NBARGS</code>. If <code>dict</code> or <code>list</code>, it is converted to a JSON string first. The notebook should read this variable with <code>os.getenv(\"REPREP_NBARGS\")</code> and not <code>stepup.core.api.getenv()</code> because the variable is local to the process. It is impossible (and pointless) for the StepUp director to detect changes in this variable. Even if it is globally defined, it will be overridden in this step.</p> </li> <li> <code>jupyter</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the jupyter executable. Defaults to <code>${REPREP_JUPYTER}</code> variable or <code>jupyter</code> if the variable is unset.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The pool in which the step is executed, which may be convenient to limit the number of parallel notebooks being executed, e.g. when the already run calculations in parallel.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_jupyter(\n    path_nb: str,\n    dest: str | None = None,\n    *,\n    inp: str | Collection[str] = (),\n    out: str | Collection[str] = (),\n    execute: bool = True,\n    to: str | None = None,\n    nbargs: str | dict | list | None = None,\n    jupyter: str | None = None,\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Convert a Jupyter notebook, by default to HTML with execution of cells.\n\n    !!! warning\n\n        Support for `juptyer nbconvert` in StepUp RepRep is experimental.\n        Expect breaking changes in future releases.\n\n    Parameters\n    ----------\n    path_nb\n        The input Jupyter notebook.\n    dest\n        Output destination: `None`, a directory or a file.\n    inp\n        One or more input files used by the notebook.\n        You can also declare inputs with `amend(inp=...)` in the notebook,\n        but specifying them here will make the scheduling more efficient.\n    out\n        One or more output files produced by the notebook.\n        You can also declare outputs with `amend(out=...)` in the notebook,\n        but you can specify them here if you want to make the notebook execution optional,\n        i.e. dependent on whether the outputs are used in other steps.\n    execute\n        If `True`, the notebook is executed before conversion.\n    to\n        The output format. The default depends on the extension of the output file.\n        if `to` is given and `dest` is `None` or a directory,\n        the `to` argument is used to determine the output file extension.\n    nbargs\n        If `str`, it is passed literally as additional argument to the notebook\n        through the environment variable `REPREP_NBARGS`.\n        If `dict` or `list`, it is converted to a JSON string first.\n        The notebook should read this variable with `os.getenv(\"REPREP_NBARGS\")`\n        and not `stepup.core.api.getenv()` because the variable is local to the process.\n        It is impossible (and pointless) for the StepUp director to detect changes in this variable.\n        Even if it is globally defined, it will be overridden in this step.\n    jupyter\n        The path to the jupyter executable.\n        Defaults to `${REPREP_JUPYTER}` variable or `jupyter` if the variable is unset.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    pool\n        The pool in which the step is executed,\n        which may be convenient to limit the number of parallel notebooks being executed,\n        e.g. when the already run calculations in parallel.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_nb = subs(path_nb)\n        dest = subs(dest)\n    if not path_nb.endswith(\".ipynb\"):\n        raise ValueError(\"The notebook file must have extension .ipynb\")\n    if isinstance(inp, str):\n        inp = [inp]\n    if isinstance(out, str):\n        out = [out]\n    default_exts = {\n        \"html\": \".html\",\n        \"pdf\": \".pdf\",\n        \"notebook\": \".ipynb\",\n        \"latex\": \".tex\",\n        \"markdown\": \".md\",\n        \"rst\": \".rst\",\n        \"script\": \".py\",\n        \"asciidoc\": \".txt\",\n    }\n    if to is not None:\n        default_ext = default_exts.get(to)\n        if default_ext is None:\n            raise ValueError(f\"Unsupported output format: {to}\")\n    else:\n        default_ext = \".html\"\n    other_exts = [\".html\", \".pdf\", \".ipynb\", \".tex\", \".md\", \".rst\", \".py\", \".txt\"]\n    path_out = make_path_out(path_nb, dest, default_ext, other_exts)\n    if to is None:\n        default_formats = {val: key for key, val in default_exts.items()}\n        to = default_formats[path_out.suffix]\n    if jupyter is None:\n        jupyter = getenv(\"REPREP_JUPYTER\", \"jupyter\")\n    args = [jupyter, \"nbconvert\", shlex.quote(path_nb), \"--stdout\", \"--to\", to]\n    if execute:\n        args.append(\"--execute\")\n    if nbargs is not None:\n        if isinstance(nbargs, dict | list):\n            nbargs = json.dumps(nbargs)\n        elif not isinstance(nbargs, str):\n            nbargs = str(nbargs)\n        args.insert(0, \"REPREP_NBARGS=\" + shlex.quote(nbargs))\n    args.extend([\"&gt;\", shlex.quote(path_out)])\n    runsh(\n        \" \".join(args),\n        inp=[path_nb, *inp],\n        out=[path_out, *out],\n        optional=optional,\n        pool=pool,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_markdown","title":"<code>convert_markdown(path_md, dest=None, *, paths_css=(), optional=False, block=False)</code>","text":"<p>Convert a markdown to HTML.</p> <p>Parameters:</p> <ul> <li> <code>path_md</code>               (<code>str</code>)           \u2013            <p>The markdown input file.</p> </li> <li> <code>dest</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output destination: <code>None</code>, a directory or a file.</p> </li> <li> <code>paths_css</code>               (<code>str | Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Path or multiple paths of a local CSS file, or a list of multiple such paths, to be included in the HTML header. Note that one may also specify CSS file in the markdown header. Defaults to <code>${REPREP_MARKDOWN_CSS}</code> if the variable is set, which is interpreted as a colon-separated list of files.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_markdown(\n    path_md: str,\n    dest: str | None = None,\n    *,\n    paths_css: str | Collection[str] = (),\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Convert a markdown to HTML.\n\n    Parameters\n    ----------\n    path_md\n        The markdown input file.\n    dest\n        Output destination: `None`, a directory or a file.\n    paths_css\n        Path or multiple paths of a local CSS file, or a list of multiple such paths,\n        to be included in the HTML header.\n        Note that one may also specify CSS file in the markdown header.\n        Defaults to `${REPREP_MARKDOWN_CSS}` if the variable is set,\n        which is interpreted as a colon-separated list of files.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_md = subs(path_md)\n        dest = subs(dest)\n    if not path_md.endswith(\".md\"):\n        raise ValueError(\"The Markdown file must have extension .md\")\n    path_html = make_path_out(path_md, dest, \".html\")\n    inp = [path_md]\n    args = [\"convert-markdown\", shlex.quote(path_md), shlex.quote(path_html)]\n    if len(paths_css) &gt; 0:\n        if isinstance(paths_css, str):\n            paths_css = [paths_css]\n        args.append(\"--css\")\n        args.extend(shlex.quote(path_css) for path_css in paths_css)\n        inp.extend(paths_css)\n    return step(\" \".join(args), inp=inp, out=path_html, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_mutool","title":"<code>convert_mutool(path_pdf, path_out, *, resolution=None, mutool=None, optional=False, block=False)</code>","text":"<p>Convert a PDF to a bitmap with mutool (from MuPDF).</p> <p>Parameters:</p> <ul> <li> <code>path_pdf</code>               (<code>str</code>)           \u2013            <p>The input PDF file.</p> </li> <li> <code>path_out</code>               (<code>str</code>)           \u2013            <p>The output image file.</p> </li> <li> <code>resolution</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the output bitmap in dots per inch (dpi).</p> </li> <li> <code>mutool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the mutool executable. Defaults to <code>${REPREP_MUTOOL}</code> variable or <code>mutool</code> if the variable is unset.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_mutool(\n    path_pdf: str,\n    path_out: str,\n    *,\n    resolution: int | None = None,\n    mutool: str | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Convert a PDF to a bitmap with mutool (from MuPDF).\n\n    Parameters\n    ----------\n    path_pdf\n        The input PDF file.\n    path_out\n        The output image file.\n    resolution\n        The resolution of the output bitmap in dots per inch (dpi).\n    mutool\n        The path to the mutool executable.\n        Defaults to `${REPREP_MUTOOL}` variable or `mutool` if the variable is unset.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    if resolution is None:\n        resolution = int(getenv(\"REPREP_CONVERT_PDF_RESOLUTION\", \"100\"))\n    if mutool is None:\n        mutool = getenv(\"REPREP_MUTOOL\", \"mutool\")\n    args = [shlex.quote(mutool), \"draw -q -o ${out} -r\", shlex.quote(str(resolution)), \"${inp}\"]\n    return runsh(\n        \" \".join(args),\n        inp=path_pdf,\n        out=path_out,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_mutool_png","title":"<code>convert_mutool_png(path_pdf, dest=None, *, resolution=None, mutool=None, optional=False, block=False)</code>","text":"<p>Shorthand for <code>convert_mutool</code> with the output file derived from the PDF file.</p> <p>The <code>dest</code> argument can be <code>None</code>, a directory or a file. See <code>make_path_out</code>.</p> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_mutool_png(\n    path_pdf: str,\n    dest: str | None = None,\n    *,\n    resolution: int | None = None,\n    mutool: str | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Shorthand for `convert_mutool` with the output file derived from the PDF file.\n\n    The `dest` argument can be `None`, a directory or a file. See `make_path_out`.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_pdf = subs(path_pdf)\n        dest = subs(dest)\n    if not path_pdf.endswith(\".pdf\"):\n        raise ValueError(\"The PDF file must have extension .pdf\")\n    path_png = make_path_out(path_pdf, dest, \".png\")\n    return convert_mutool(\n        path_pdf, path_png, resolution=resolution, mutool=mutool, optional=optional, block=block\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_odf_pdf","title":"<code>convert_odf_pdf(path_odf, dest=None, *, libreoffice=None, optional=False, block=False)</code>","text":"<p>Convert a file in OpenDocument format to PDF.</p> <p>Parameters:</p> <ul> <li> <code>path_odf</code>               (<code>str</code>)           \u2013            <p>The input open-document file.</p> </li> <li> <code>dest</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>None, output directory or path. See <code>make_path_out</code>.</p> </li> <li> <code>libreoffice</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The libreoffice executable. Defaults to <code>${REPREP_LIBREOFFICE}</code> variable or <code>libreoffice</code> if the variable is unset.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Notes <p>This function does not yet scan the source document for reference to external files. which should ideally be added as dependencies.</p> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_odf_pdf(\n    path_odf: str,\n    dest: str | None = None,\n    *,\n    libreoffice: str | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Convert a file in OpenDocument format to PDF.\n\n    Parameters\n    ----------\n    path_odf\n        The input open-document file.\n    dest\n        None, output directory or path. See `make_path_out`.\n    libreoffice\n        The libreoffice executable.\n        Defaults to `${REPREP_LIBREOFFICE}` variable or `libreoffice` if the variable is unset.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n\n    Notes\n    -----\n    This function does not yet scan the source document for reference to external files.\n    which should ideally be added as dependencies.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_odf = subs(path_odf)\n        dest = subs(dest)\n    if libreoffice is None:\n        libreoffice = getenv(\"REPREP_LIBREOFFICE\", \"libreoffice\")\n    command = (\n        # Simple things should be simple! ;) See:\n        # https://bugs.documentfoundation.org/show_bug.cgi?id=106134\n        # https://bugs.documentfoundation.org/show_bug.cgi?id=152192\n        # Not solved yet:\n        # https://bugs.documentfoundation.org/show_bug.cgi?id=160033\n        \"WORK=`mktemp -d --suffix=reprep` &amp;&amp; \"\n        + shlex.quote(libreoffice)\n        + \" -env:UserInstallation=file://${WORK} --convert-to pdf ${inp} --outdir ${WORK} \"\n        \"&gt; /dev/null &amp;&amp; cp ${WORK}/*.pdf ${out} &amp;&amp; rm -r ${WORK}\"\n    )\n    path_pdf = make_path_out(path_odf, dest, \".pdf\")\n    return runsh(command, inp=path_odf, out=path_pdf, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.convert_weasyprint","title":"<code>convert_weasyprint(path_html, dest=None, *, weasyprint=None, optional=False, block=False)</code>","text":"<p>Convert a HTML document to PDF.</p> <p>Parameters:</p> <ul> <li> <code>path_html</code>               (<code>str</code>)           \u2013            <p>The HTML input file.</p> </li> <li> <code>dest</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output destination: <code>None</code>, a directory or a file.</p> </li> <li> <code>weasyprint</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the weasyprint executable. Defaults to <code>${REPREP_WEASYPRINT}</code> variable or <code>weasyprint</code> if the variable is unset.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def convert_weasyprint(\n    path_html: str,\n    dest: str | None = None,\n    *,\n    weasyprint: str | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Convert a HTML document to PDF.\n\n    Parameters\n    ----------\n    path_html\n        The HTML input file.\n    dest\n        Output destination: `None`, a directory or a file.\n    weasyprint\n        The path to the weasyprint executable.\n        Defaults to `${REPREP_WEASYPRINT}` variable or `weasyprint` if the variable is unset.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_html = subs(path_html)\n        dest = subs(dest)\n    if not path_html.endswith(\".html\"):\n        raise ValueError(\"The HTML file must have extension .html\")\n    path_pdf = make_path_out(path_html, dest, \".pdf\")\n    args = [\n        \"convert-weasyprint\",\n        shlex.quote(path_html),\n        shlex.quote(path_pdf),\n    ]\n    if weasyprint is not None:\n        args.append(\"--weasyprint=\" + shlex.quote(weasyprint))\n    return step(\" \".join(args), inp=path_html, out=path_pdf, block=block, optional=optional)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.diff_latex","title":"<code>diff_latex(path_old, path_new, path_diff, *, latexdiff=None, latexdiff_args=DEFAULT_LATEXDIFF_ARGS, optional=False, block=False)</code>","text":"<p>Create a step to run latexdiff.</p> <p>Parameters:</p> <ul> <li> <code>path_old</code>               (<code>str</code>)           \u2013            <p>The old tex or bbl source.</p> </li> <li> <code>path_new</code>               (<code>str</code>)           \u2013            <p>The new tex or bbl source.</p> </li> <li> <code>path_diff</code>               (<code>str</code>)           \u2013            <p>The diff output tex or bbl.</p> </li> <li> <code>latexdiff</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Path of the latexdiff  executable. Defaults to <code>${REPREP_LATEXDIFF}</code> variable or <code>latexdiff</code> if the variable is unset.</p> </li> <li> <code>latexdiff_args</code>               (<code>Collection[str]</code>, default:                   <code>DEFAULT_LATEXDIFF_ARGS</code> )           \u2013            <p>Additional arguments for latexdiff. Defaults to <code>${REPREP_LATEXDIFF_ARG}</code> variable. If this variable is unset, the following default is used:</p> <pre><code>--append-context2cmd=abstract,supplementary,dataavailability,funding, \\\n                     authorcontributions,conflictsofinterest,abbreviations\n</code></pre> <p>The option <code>--no-label</code> is always added because it is needed to make the file reproducible.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def diff_latex(\n    path_old: str,\n    path_new: str,\n    path_diff: str,\n    *,\n    latexdiff: str | None = None,\n    latexdiff_args: Collection[str] = DEFAULT_LATEXDIFF_ARGS,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    r\"\"\"Create a step to run latexdiff.\n\n    Parameters\n    ----------\n    path_old\n        The old tex or bbl source.\n    path_new\n        The new tex or bbl source.\n    path_diff\n        The diff output tex or bbl.\n    latexdiff\n        Path of the latexdiff  executable.\n        Defaults to `${REPREP_LATEXDIFF}` variable or `latexdiff` if the variable is unset.\n    latexdiff_args\n        Additional arguments for latexdiff.\n        Defaults to `${REPREP_LATEXDIFF_ARG}` variable.\n        If this variable is unset, the following default is used:\n\n        ```\n        --append-context2cmd=abstract,supplementary,dataavailability,funding, \\\n                             authorcontributions,conflictsofinterest,abbreviations\n        ```\n\n        The option `--no-label` is always added because it is needed to make the file reproducible.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    if latexdiff is None:\n        latexdiff = getenv(\"REPREP_LATEXDIFF\", \"latexdiff\")\n\n    if latexdiff_args is None:\n        latexdiff_args = shlex.split(getenv(\"REPREP_LATEXDIFF_ARGS\", \"\"))\n\n    args = [shlex.quote(latexdiff)]\n    args.extend(shlex.quote(latexdiff_arg) for latexdiff_arg in latexdiff_args)\n    args.extend([\"${inp}\", \"--no-label\", \"&gt;\", \"${out}\"])\n    return runsh(\n        \" \".join(args),\n        inp=[path_old, path_new],\n        out=path_diff,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.execute_papermill","title":"<code>execute_papermill(path_nb, dest, *, inp=(), out=(), parameters=None, optional=False, pool=None, block=False)</code>","text":"<p>Execute a Jupyter Notebook with papermill and save the notebook with outputs as a new file.</p> <p>Parameters:</p> <ul> <li> <code>path_nb</code>               (<code>str</code>)           \u2013            <p>The input Jupyter notebook.</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>Output destination: a directory or a file. The output format is always IPYNB.</p> </li> <li> <code>inp</code>               (<code>str | Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more input files used by the notebook. You can also declare inputs with <code>amend(inp=...)</code> in the notebook, but specifying them here will make the scheduling more efficient.</p> </li> <li> <code>out</code>               (<code>str | Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more output files produced by the notebook. You can also declare outputs with <code>amend(out=...)</code> in the notebook, but you can specify them here if you want to make the notebook execution optional, i.e. dependent on whether the outputs are used in other steps.</p> </li> <li> <code>parameters</code>               (<code>dict[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary, if any, must be JSON-serializable. It will be passed to the parameters argument of <code>papermill.execute_notebook()</code>.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>pool</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The pool in which the step is executed, which may be convenient to limit the number of parallel notebooks being executed, e.g. when the already run calculations in parallel.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def execute_papermill(\n    path_nb: str,\n    dest: str,\n    *,\n    inp: str | Collection[str] = (),\n    out: str | Collection[str] = (),\n    parameters: dict[str] | None = None,\n    optional: bool = False,\n    pool: str | None = None,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Execute a Jupyter Notebook with papermill and save the notebook with outputs as a new file.\n\n    Parameters\n    ----------\n    path_nb\n        The input Jupyter notebook.\n    dest\n        Output destination: a directory or a file.\n        The output format is always IPYNB.\n    inp\n        One or more input files used by the notebook.\n        You can also declare inputs with `amend(inp=...)` in the notebook,\n        but specifying them here will make the scheduling more efficient.\n    out\n        One or more output files produced by the notebook.\n        You can also declare outputs with `amend(out=...)` in the notebook,\n        but you can specify them here if you want to make the notebook execution optional,\n        i.e. dependent on whether the outputs are used in other steps.\n    parameters\n        The dictionary, if any, must be JSON-serializable.\n        It will be passed to the parameters argument of `papermill.execute_notebook()`.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    pool\n        The pool in which the step is executed,\n        which may be convenient to limit the number of parallel notebooks being executed,\n        e.g. when the already run calculations in parallel.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_nb = subs(path_nb)\n        dest = subs(dest)\n    if not path_nb.endswith(\".ipynb\"):\n        raise ValueError(\"The notebook file must have extension .ipynb\")\n    if isinstance(inp, str):\n        inp = [inp]\n    if isinstance(out, str):\n        out = [out]\n    path_out = make_path_out(path_nb, dest, \".ipynb\")\n    if parameters is None:\n        parameters = {}\n    args = [\"execute-papermill\", shlex.quote(path_nb)]\n    if len(parameters) &gt; 0:\n        args.append(shlex.quote(json.dumps(parameters)))\n    args.append(shlex.quote(path_out))\n    step(\n        \" \".join(args),\n        inp=[path_nb, *inp],\n        out=[path_out, *out],\n        optional=optional,\n        pool=pool,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.flatten_latex","title":"<code>flatten_latex(path_tex, path_flat, *, optional=False, block=False)</code>","text":"<p>Flatten structured LaTeX source files (substitute <code>\\input</code> and friends by their content).</p> <p>Parameters:</p> <ul> <li> <code>path_tex</code>               (<code>str</code>)           \u2013            <p>The main tex file to be converted.</p> </li> <li> <code>path_flat</code>               (<code>str</code>)           \u2013            <p>The flattened output file.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def flatten_latex(path_tex: str, path_flat: str, *, optional: bool = False, block: bool = False):\n    r\"\"\"Flatten structured LaTeX source files (substitute `\\input` and friends by their content).\n\n    Parameters\n    ----------\n    path_tex\n        The main tex file to be converted.\n    path_flat\n        The flattened output file.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    return step(\n        \"flatten-latex ${inp} ${out}\",\n        inp=path_tex,\n        out=path_flat,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.make_inventory","title":"<code>make_inventory(*paths, path_def=None, optional=False, block=False)</code>","text":"<p>Create an <code>inventory.txt</code> file.</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Paths to include in the <code>inventory.txt</code> file, except for the last, which is the inventory file to write.</p> </li> <li> <code>path_def</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An inventory definitions file, used to constructe the list of files.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def make_inventory(\n    *paths: Collection[str],\n    path_def: str | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Create an `inventory.txt` file.\n\n    Parameters\n    ----------\n    paths\n        Paths to include in the `inventory.txt` file,\n        except for the last, which is the inventory file to write.\n    path_def\n        An inventory definitions file, used to constructe the list of files.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    if len(paths) &lt; 1:\n        raise ValueError(\"At least one path must be given.\")\n    paths_inp = list(paths[:-1])\n    args = [\"make-inventory\", *paths_inp]\n    if path_def is not None:\n        args.extend([\"-i\", path_def])\n        paths_inp.append(path_def)\n    args.extend([\"-o\", paths[-1]])\n    return step(\n        shlex.join(args),\n        inp=paths_inp,\n        out=[paths[-1]],\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.nup_pdf","title":"<code>nup_pdf(path_src, path_dst, *, nrow=None, ncol=None, margin=None, page_format=None, optional=False, block=False)</code>","text":"<p>Put multiple pages per sheet using a fixed layout.</p> <p>Parameters:</p> <ul> <li> <code>path_src</code>               (<code>str</code>)           \u2013            <p>The original PDF document (with normal pages).</p> </li> <li> <code>path_dst</code>               (<code>str</code>)           \u2013            <p>The output PDF with (multiple pages per sheet).</p> </li> <li> <code>nrow</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of rows on each output sheet. The default is <code>${REPREP_NUP_NROW}</code> or 2 if the variable is not set.</p> </li> <li> <code>ncol</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of columns on each output sheet. The default is <code>${REPREP_NUP_NCOL}</code> or 2 if the variable is not set.</p> </li> <li> <code>margin</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The margin in mm between the pages on each sheet. (Also used as sheet margin.) The default is <code>${REPREP_NUP_MARGIN}</code> or 10.0 if the variable is not set.</p> </li> <li> <code>page_format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output page format The default is <code>${REPREP_NUP_PAGE_FORMAT}</code> or A4-L if the variable is not set.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def nup_pdf(\n    path_src: str,\n    path_dst: str,\n    *,\n    nrow: int | None = None,\n    ncol: int | None = None,\n    margin: float | None = None,\n    page_format: str | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Put multiple pages per sheet using a fixed layout.\n\n    Parameters\n    ----------\n    path_src\n        The original PDF document (with normal pages).\n    path_dst\n        The output PDF with (multiple pages per sheet).\n    nrow\n        The number of rows on each output sheet.\n        The default is `${REPREP_NUP_NROW}` or 2 if the variable is not set.\n    ncol\n        The number of columns on each output sheet.\n        The default is `${REPREP_NUP_NCOL}` or 2 if the variable is not set.\n    margin\n        The margin in mm between the pages on each sheet. (Also used as sheet margin.)\n        The default is `${REPREP_NUP_MARGIN}` or 10.0 if the variable is not set.\n    page_format\n        The output page format\n        The default is `${REPREP_NUP_PAGE_FORMAT}` or A4-L if the variable is not set.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    args = [\"nup-pdf\", \"${inp}\", \"${out}\"]\n    if nrow is not None:\n        args.extend([\"-r\", str(nrow)])\n    if ncol is not None:\n        args.extend([\"-c\", str(ncol)])\n    if margin is not None:\n        args.extend([\"-m\", str(margin)])\n    if page_format is not None:\n        args.extend([\"-p\", shlex.quote(page_format)])\n    return step(\" \".join(args), inp=path_src, out=path_dst, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.raster_pdf","title":"<code>raster_pdf(path_inp, dest, *, resolution=None, quality=None, optional=False, block=False)</code>","text":"<p>Turn each page of a PDF into a rendered JPEG bitmap contained in a new PDF.</p> <p>Parameters:</p> <ul> <li> <code>path_inp</code>               (<code>str</code>)           \u2013            <p>The input PDF file.</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>None, output directory or path. See <code>make_path_out</code>.</p> </li> <li> <code>resolution</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the bitmap in dots per inch (dpi). The default value is taken from <code>${REPREP_RASTER_RESOLUTION}</code> or 100 if the variable is not set.</p> </li> <li> <code>quality</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The JPEG quality of the bitmap. The default value is taken from <code>${REPREP_RASTER_QUALITY}</code> or 50 if the variable is not set.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def raster_pdf(\n    path_inp: str,\n    dest: str,\n    *,\n    resolution: int | None = None,\n    quality: int | None = None,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Turn each page of a PDF into a rendered JPEG bitmap contained in a new PDF.\n\n    Parameters\n    ----------\n    path_inp\n        The input PDF file.\n    dest\n        None, output directory or path. See `make_path_out`.\n    resolution\n        The resolution of the bitmap in dots per inch (dpi).\n        The default value is taken from `${REPREP_RASTER_RESOLUTION}` or 100 if the variable is not\n        set.\n    quality\n        The JPEG quality of the bitmap.\n        The default value is taken from `${REPREP_RASTER_QUALITY}` or 50 if the variable is not set.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    args = [\"raster-pdf\", \"${inp}\", \"${out}\"]\n    if resolution is not None:\n        args.extend([\"-r\", str(resolution)])\n    if quality is not None:\n        args.extend([\"-q\", shlex.quote(str(quality))])\n    path_out = make_path_out(path_inp, dest, \".pdf\")\n    return step(\" \".join(args), inp=path_inp, out=path_out, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.sanitize_bibtex","title":"<code>sanitize_bibtex(path_bib, *, path_aux=None, path_cfg=None, path_out=None, overwrite=False, optional=False, block=False)</code>","text":"<p>Sanitize a BibTeX file.</p> <p>Parameters:</p> <ul> <li> <code>path_bib</code>               (<code>str</code>)           \u2013            <p>Path to the BibTeX file to be sanitized.</p> </li> <li> <code>path_aux</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Paths to LaTeX aux file if any. This is used to detect unused or missing citations.</p> </li> <li> <code>path_cfg</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The YAML configuration file for the <code>rr-sanitize-bibtex</code> script.</p> </li> <li> <code>path_out</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If given, a single cleaned-up bibtex file is written as output, which you can manually copy back to the original if you approve of the cleanup. If not given, the original bibtex file is overwritten (if there is only one), which will drain the scheduler. You then check if the updated version is correct and rerun the build to approve.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, it is assumed that you want to overwrite an input bibtex file, in which case <code>path_out</code> is not treated as a new output file in the workflow.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def sanitize_bibtex(\n    path_bib: str,\n    *,\n    path_aux: str | None = None,\n    path_cfg: str | None = None,\n    path_out: str | None = None,\n    overwrite: bool = False,\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Sanitize a BibTeX file.\n\n    Parameters\n    ----------\n    path_bib\n        Path to the BibTeX file to be sanitized.\n    path_aux\n        Paths to LaTeX aux file if any.\n        This is used to detect unused or missing citations.\n    path_cfg\n        The YAML configuration file for the `rr-sanitize-bibtex` script.\n    path_out\n        If given, a single cleaned-up bibtex file is written as output,\n        which you can manually copy back to the original if you approve of the cleanup.\n        If not given, the original bibtex file is overwritten (if there is only one),\n        which will drain the scheduler.\n        You then check if the updated version is correct and rerun the build to approve.\n    overwrite\n        If `True`, it is assumed that you want to overwrite an input bibtex file,\n        in which case `path_out` is not treated as a new output file in the workflow.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    with subs_env_vars() as subs:\n        path_bib = subs(path_bib)\n        path_cfg = subs(path_cfg)\n        path_aux = subs(path_aux)\n        path_out = subs(path_out)\n\n    args = [\"bibsane\", shlex.quote(path_bib)]\n    paths_inp = [path_bib]\n    if path_aux is not None:\n        args.append(\"--aux=\" + shlex.quote(path_aux))\n        paths_inp.append(path_aux)\n    if path_cfg is not None:\n        args.append(\"--config=\" + shlex.quote(path_cfg))\n        paths_inp.append(path_cfg)\n    paths_out = []\n    if path_out is not None:\n        args.append(\"--out=\" + shlex.quote(path_out))\n        if not overwrite:\n            paths_out.append(path_out)\n    return step(\" \".join(args), inp=paths_inp, out=paths_out, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.sync_zenodo","title":"<code>sync_zenodo(path_config, *, block=False)</code>","text":"<p>Synchronize data with an draft dataset on Zenodo.</p> <p>Parameters:</p> <ul> <li> <code>path_config</code>               (<code>str</code>)           \u2013            <p>The YAML configuration file for the Zenodo upload.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def sync_zenodo(path_config: str, *, block: bool = False) -&gt; StepInfo:\n    \"\"\"Synchronize data with an draft dataset on Zenodo.\n\n    Parameters\n    ----------\n    path_config\n        The YAML configuration file for the Zenodo upload.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    return step(\"sync-zenodo ${inp}\", inp=path_config, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.unplot","title":"<code>unplot(path_svg, dest=None, *, optional=False, block=False)</code>","text":"<p>Convert a plot back to data.</p> <p>Parameters:</p> <ul> <li> <code>path_svg</code>               (<code>str</code>)           \u2013            <p>The SVG file with paths to be converted back.</p> </li> <li> <code>dest</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An output directory or file.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def unplot(\n    path_svg: str, dest: str | None = None, *, optional: bool = False, block: bool = False\n) -&gt; StepInfo:\n    \"\"\"Convert a plot back to data.\n\n    Parameters\n    ----------\n    path_svg\n        The SVG file with paths to be converted back.\n    dest\n        An output directory or file.\n\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    path_out = make_path_out(path_svg, dest, \".json\")\n    command = \"unplot ${inp} ${out}\"\n    return step(command, inp=path_svg, out=path_out, optional=optional, block=block)\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.wrap_git","title":"<code>wrap_git(command, *, out=None, workdir='./', optional=False, block=False)</code>","text":"<p>Create a step to run a git command.</p> <p>The provide the necessary input for StepUp, git is called through a wrapper script. This wrapper first infers the git root directory with <code>git rev-parse --show-toplevel</code>. It then amends the input dependencies with the following two files:</p> <ul> <li>gitroot / \u2018.git/HEAD\u2019</li> <li>gitroot / \u2018.git/refs/branches/\u2018 <p>As a result, the step will be rescheduled when the current commit id or branch changes.</p> <p>It is recommended to make gitroot / \u2018.git/\u2019 and all of its contents static with recursive deferred glob as follows:</p> <pre><code>glob(\".git/**\", _defer=True)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The git command to run, e.g. <code>git describe --tags</code> or <code>git log -n1 --pretty='format:%cs (%h)</code>.</p> </li> <li> <code>out</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An output file for the stdout of the git command.</p> </li> <li> <code>workdir</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>The working directory where the git command must be executed.</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def wrap_git(\n    command: str,\n    *,\n    out: str | None = None,\n    workdir: str = \"./\",\n    optional: bool = False,\n    block: bool = False,\n) -&gt; StepInfo:\n    \"\"\"Create a step to run a git command.\n\n    The provide the necessary input for StepUp, git is called through a wrapper script.\n    This wrapper first infers the git root directory with `git rev-parse --show-toplevel`.\n    It then amends the input dependencies with the following two files:\n\n      - gitroot / '.git/HEAD'\n      - gitroot / '.git/refs/branches/&lt;branch&gt;'\n\n    As a result, the step will be rescheduled when the current commit id or branch changes.\n\n    It is recommended to make gitroot / '.git/' and all of its contents static\n    with recursive deferred glob as follows:\n\n    ```python\n    glob(\".git/**\", _defer=True)\n    ```\n\n    Parameters\n    ----------\n    command\n        The git command to run, e.g. `git describe --tags`\n        or `git log -n1 --pretty='format:%cs (%h)`.\n    out\n        An output file for the stdout of the git command.\n    workdir\n        The working directory where the git command must be executed.\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    if not isinstance(command, str):\n        raise TypeError(\"The git command must be a string.\")\n    if not (out is None or isinstance(out, str)):\n        raise TypeError(\"The output of the git command must be a string or None.\")\n\n    action = \"wrap_git\"\n    if out is not None:\n        action += f\" --out={shlex.quote(out)}\"\n    action += f\" -- {command}\"\n    return step(\n        action,\n        out=out,\n        workdir=workdir,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.api/#stepup.reprep.api.zip_inventory","title":"<code>zip_inventory(path_inventory, path_zip, *, optional=False, block=False)</code>","text":"<p>Create a ZIP file with all files listed in a <code>inventory.txt</code> file + check digests before zip.</p> <p>Parameters:</p> <ul> <li> <code>path_inventory</code>               (<code>str</code>)           \u2013            <p>A file created with the <code>make_inventory</code> API or with the command-line script <code>rr-make-inventory</code>.</p> </li> <li> <code>path_zip</code>               (<code>str</code>)           \u2013            <p>The output ZIP file</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step is only executed when needed by other steps.</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the step will always remain pending.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>step_info</code>           \u2013            <p>Holds relevant information of the step, useful for defining follow-up steps.</p> </li> </ul> Source code in <code>stepup/reprep/api.py</code> <pre><code>def zip_inventory(\n    path_inventory: str, path_zip: str, *, optional: bool = False, block: bool = False\n) -&gt; StepInfo:\n    \"\"\"Create a ZIP file with all files listed in a `inventory.txt` file + check digests before zip.\n\n    Parameters\n    ----------\n    path_inventory\n        A file created with the `make_inventory` API or with the command-line script\n        `rr-make-inventory`.\n    path_zip\n        The output ZIP file\n    optional\n        If `True`, the step is only executed when needed by other steps.\n    block\n        If `True`, the step will always remain pending.\n\n    Returns\n    -------\n    step_info\n        Holds relevant information of the step, useful for defining follow-up steps.\n    \"\"\"\n    return step(\n        \"zip-inventory ${inp} ${out}\",\n        inp=path_inventory,\n        out=path_zip,\n        optional=optional,\n        block=block,\n    )\n</code></pre>"},{"location":"reference/stepup.reprep.bibsane/","title":"stepup.reprep.bibsane","text":"<p>Sanitize BibTeX files.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig","title":"<code>BibsaneConfig</code>","text":"<p>The configuration object controling BibSane behavior.</p> <p>Note that the settings default to the most permissive and least invasive ones. We recommend the opposite settings, but you have to switch knowingly in the config file.</p> Source code in <code>stepup/reprep/bibsane.py</code> <pre><code>@attrs.define\nclass BibsaneConfig:\n    \"\"\"The configuration object controling BibSane behavior.\n\n    Note that the settings default to the most permissive and least invasive ones.\n    We recommend the opposite settings, but you have to switch knowingly in the config file.\n    \"\"\"\n\n    root: Path = attrs.field()\n    \"\"\"The parent directory of the configuration file.\"\"\"\n\n    drop_entry_types: list[str] = attrs.field(default=attrs.Factory(list))\n    \"\"\"The entry types to drop from the BibTeX database.\"\"\"\n\n    normalize_doi: bool = attrs.field(default=False)\n    \"\"\"Set to `True` to normalize the DOIs in the entries.\"\"\"\n\n    duplicate_id: DuplicatePolicy = attrs.field(default=DuplicatePolicy.IGNORE)\n    \"\"\"The policy for duplicate BibTeX IDs: fail, merge or ignore.\"\"\"\n\n    duplicate_doi: DuplicatePolicy = attrs.field(default=DuplicatePolicy.IGNORE)\n    \"\"\"The policy for duplicate DOIs: fail, merge or ignore.\"\"\"\n\n    preambles_allowed: bool = attrs.field(default=True)\n    \"\"\"Set to `False` to disallow @preamble entries in the BibTeX database.\"\"\"\n\n    normalize_whitespace: bool = attrs.field(default=False)\n    \"\"\"Set to `True` to normalize the whitespace in the field values.\"\"\"\n\n    normalize_names: bool = attrs.field(default=False)\n    \"\"\"Set to `True` to normalize the author and editor names.\n\n    (This currently broken.)\n    \"\"\"\n\n    fix_page_double_hyphen: bool = attrs.field(default=False)\n    \"\"\"Set to `True` to fix the page ranges for which no double hyphen is used.\"\"\"\n\n    abbreviate_journals: bool = attrs.field(default=True)\n\n    custom_abbreviations: dict[str, str] = attrs.field(factory=dict)\n    \"\"\"Custom journal abbreviations.\n\n    By default, pyiso4 is used to abbreviate journal names.\n    The custom abbreviations can override those provided by pyiso4.\n    \"\"\"\n\n    sort: bool = attrs.field(default=False)\n    \"\"\"Set to `True` to sort the entries by year and first author.\n\n    The sort key is `{year}{first author lowercase last name}`.\n    \"\"\"\n\n    citation_policies: dict[str, dict[str, FieldPolicy]] = attrs.field(default=attrs.Factory(dict))\n    \"\"\"The field policies (must or may) for each entry type.\"\"\"\n\n    @classmethod\n    def from_file(cls, fn_yaml: str):\n        \"\"\"Instantiate a configuration from a YAML config file.\"\"\"\n        if fn_yaml is None:\n            config = cls(os.getcwd())\n        else:\n            with open(fn_yaml) as f:\n                data = yaml.safe_load(f)\n                data.setdefault(\"root\", os.path.dirname(fn_yaml))\n                config = cattrs.structure(data, cls)\n        return config\n</code></pre>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.citation_policies","title":"<code>citation_policies = attrs.field(default=attrs.Factory(dict))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The field policies (must or may) for each entry type.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.custom_abbreviations","title":"<code>custom_abbreviations = attrs.field(factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom journal abbreviations.</p> <p>By default, pyiso4 is used to abbreviate journal names. The custom abbreviations can override those provided by pyiso4.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.drop_entry_types","title":"<code>drop_entry_types = attrs.field(default=attrs.Factory(list))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entry types to drop from the BibTeX database.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.duplicate_doi","title":"<code>duplicate_doi = attrs.field(default=DuplicatePolicy.IGNORE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The policy for duplicate DOIs: fail, merge or ignore.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.duplicate_id","title":"<code>duplicate_id = attrs.field(default=DuplicatePolicy.IGNORE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The policy for duplicate BibTeX IDs: fail, merge or ignore.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.fix_page_double_hyphen","title":"<code>fix_page_double_hyphen = attrs.field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set to <code>True</code> to fix the page ranges for which no double hyphen is used.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.normalize_doi","title":"<code>normalize_doi = attrs.field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set to <code>True</code> to normalize the DOIs in the entries.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.normalize_names","title":"<code>normalize_names = attrs.field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set to <code>True</code> to normalize the author and editor names.</p> <p>(This currently broken.)</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.normalize_whitespace","title":"<code>normalize_whitespace = attrs.field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set to <code>True</code> to normalize the whitespace in the field values.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.preambles_allowed","title":"<code>preambles_allowed = attrs.field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set to <code>False</code> to disallow @preamble entries in the BibTeX database.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.root","title":"<code>root = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The parent directory of the configuration file.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.sort","title":"<code>sort = attrs.field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set to <code>True</code> to sort the entries by year and first author.</p> <p>The sort key is <code>{year}{first author lowercase last name}</code>.</p>"},{"location":"reference/stepup.reprep.bibsane/#stepup.reprep.bibsane.BibsaneConfig.from_file","title":"<code>from_file(fn_yaml)</code>  <code>classmethod</code>","text":"<p>Instantiate a configuration from a YAML config file.</p> Source code in <code>stepup/reprep/bibsane.py</code> <pre><code>@classmethod\ndef from_file(cls, fn_yaml: str):\n    \"\"\"Instantiate a configuration from a YAML config file.\"\"\"\n    if fn_yaml is None:\n        config = cls(os.getcwd())\n    else:\n        with open(fn_yaml) as f:\n            data = yaml.safe_load(f)\n            data.setdefault(\"root\", os.path.dirname(fn_yaml))\n            config = cattrs.structure(data, cls)\n    return config\n</code></pre>"},{"location":"reference/stepup.reprep.tile_pdf/","title":"stepup.reprep.tile_pdf","text":"<p>Tile PDF figures.</p>"},{"location":"reference/stepup.reprep.tile_pdf/#stepup.reprep.tile_pdf.Figure","title":"<code>Figure</code>","text":"<p>The definition of a tiled figure</p> <p>Attributes:</p> <ul> <li> <code>path_out</code>               (<code>str</code>)           \u2013            <p>The PDF output file.</p> </li> <li> <code>panels</code>               (<code>list[Panel]</code>)           \u2013            <p>The list panels, instances of the <code>Panel</code> class.</p> </li> <li> <code>fontname</code>               (<code>str</code>)           \u2013            <p>A Fontname recognized by PyMyPDF or a custom name when fontfile is specified.</p> </li> <li> <code>fontfile</code>               (<code>str | None</code>)           \u2013            <p>None or the path to a ttf file. When used, specify a corresponding fontname (of your choice).</p> </li> <li> <code>fontsize</code>               (<code>float</code>)           \u2013            <p>The font size to use for the labels in points.</p> </li> <li> <code>label_height</code>               (<code>float</code>)           \u2013            <p>The height to use for the labels in mm.</p> </li> <li> <code>padding</code>               (<code>float</code>)           \u2013            <p>The padding added added to the panels before combining them, in mm. This parameter is also used as margin between the label and the figure.</p> </li> <li> <code>hshift</code>               (<code>float</code>)           \u2013            <p>An optional horizontal displacement of the panel label, in mm.</p> </li> </ul> Source code in <code>stepup/reprep/tile_pdf.py</code> <pre><code>@attrs.define\nclass Figure:\n    \"\"\"The definition of a tiled figure\n\n    Attributes\n    ----------\n    path_out\n        The PDF output file.\n    panels\n        The list panels, instances of the `Panel` class.\n    fontname\n        A Fontname recognized by PyMyPDF or a custom name when fontfile is specified.\n    fontfile\n        None or the path to a ttf file.\n        When used, specify a corresponding fontname (of your choice).\n    fontsize\n        The font size to use for the labels in points.\n    label_height\n        The height to use for the labels in mm.\n    padding\n        The padding added added to the panels before combining them, in mm.\n        This parameter is also used as margin between the label and the figure.\n    hshift\n        An optional horizontal displacement of the panel label, in mm.\n    \"\"\"\n\n    path_out: str = attrs.field()\n    panels: list[Panel] = attrs.field()\n    fontname: str = attrs.field(default=\"hebo\")\n    fontfile: str | None = attrs.field(default=None)\n    # Dimensions in points. (1 point = 1/72 inch)\n    fontsize: float = attrs.field(default=7.0)\n    label_height: float = attrs.field(default=2.0)\n    padding: float = attrs.field(default=1.0)\n    hshift: float = attrs.field(default=0.0)\n\n    def info(self):\n        inp = [panel.path_in for panel in self.panels]\n        if self.fontfile is not None:\n            inp.append(self.fontfile)\n        return {\"inp\": inp, \"out\": self.path_out}\n\n    def run(self):\n        \"\"\"Combine PDF figures into a single PDF with labels on top of each panel.\"\"\"\n        _load_pdfs(self.panels)\n        for panel in self.panels:\n            _add_label(panel, self)\n        out = _combine_figures(self.panels)\n        out.set_metadata({})\n        out.del_xml_metadata()\n        out.scrub()\n        out.save(self.path_out, garbage=4, deflate=True, no_new_id=True)\n</code></pre>"},{"location":"reference/stepup.reprep.tile_pdf/#stepup.reprep.tile_pdf.Figure.run","title":"<code>run()</code>","text":"<p>Combine PDF figures into a single PDF with labels on top of each panel.</p> Source code in <code>stepup/reprep/tile_pdf.py</code> <pre><code>def run(self):\n    \"\"\"Combine PDF figures into a single PDF with labels on top of each panel.\"\"\"\n    _load_pdfs(self.panels)\n    for panel in self.panels:\n        _add_label(panel, self)\n    out = _combine_figures(self.panels)\n    out.set_metadata({})\n    out.del_xml_metadata()\n    out.scrub()\n    out.save(self.path_out, garbage=4, deflate=True, no_new_id=True)\n</code></pre>"},{"location":"reference/stepup.reprep.tile_pdf/#stepup.reprep.tile_pdf.Panel","title":"<code>Panel</code>","text":"<p>The definition of one panel in a tiled figure.</p> <p>Attributes:</p> <ul> <li> <code>irow</code>               (<code>int</code>)           \u2013            <p>The row where the panel is located (top left corner).</p> </li> <li> <code>icol</code>               (<code>int</code>)           \u2013            <p>The column where the panel is located (top left corner).</p> </li> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The label to be put above the panel.</p> </li> <li> <code>path_in</code>               (<code>str</code>)           \u2013            <p>The path of the PDF file with the figure.</p> </li> <li> <code>nrow</code>               (<code>int</code>)           \u2013            <p>The number of rows occupied by the panel.</p> </li> <li> <code>ncol</code>               (<code>int</code>)           \u2013            <p>The number of columns occupied by the panel.</p> </li> </ul> Source code in <code>stepup/reprep/tile_pdf.py</code> <pre><code>@attrs.define\nclass Panel:\n    \"\"\"The definition of one panel in a tiled figure.\n\n    Attributes\n    ----------\n    irow\n        The row where the panel is located (top left corner).\n    icol\n        The column where the panel is located (top left corner).\n    label\n        The label to be put above the panel.\n    path_in\n        The path of the PDF file with the figure.\n    nrow\n        The number of rows occupied by the panel.\n    ncol\n        The number of columns occupied by the panel.\n    \"\"\"\n\n    irow: int = attrs.field()\n    icol: int = attrs.field()\n    label: str = attrs.field()\n    path_in: str = attrs.field()\n    nrow: int = attrs.field(default=1)\n    ncol: int = attrs.field(default=1)\n    pdf = attrs.field(default=None)\n</code></pre>"}]}